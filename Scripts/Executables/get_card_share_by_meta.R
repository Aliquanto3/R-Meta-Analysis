################################################################################
#####                  MTG Tournament Result Analysis                      #####
#####                           by Anaël Yahi                              #####
#####               based on data generated by Phelps-san                  #####
#####            https://github.com/Badaro/MTGOArchetypeParser             #####
################################################################################
#####                              Main.R                                  #####
##### Use this file as a controller of the others to generate most results #####
################################################################################

########################   Import data and functions   ######################### 

# Import the parameters, libraries and functions from other scripts
# Once the code is stable, it should be turned into packages
ScriptDir = "Scripts/"
importableScriptDir = paste0(ScriptDir,"Imports/")

parameterScriptDir = paste0(importableScriptDir,"Parameters/")
source(file.path(paste0(parameterScriptDir,"Parameters.R")))

functionScriptDir = paste0(importableScriptDir,"Functions/")
source(file.path(paste0(functionScriptDir,"01-Tournament_Data_Import.R")))
source(file.path(paste0(functionScriptDir,"02-Simple_Getters.R")))
source(file.path(paste0(functionScriptDir,"03-Metagame_Data_Treatment.R")))
source(file.path(paste0(functionScriptDir,"04-Metagame_Graph_Generation.R")))
source(file.path(paste0(functionScriptDir,"05-Decklist_Analysis.R")))
source(file.path(paste0(functionScriptDir,"06-Player_Data_Treatment.R")))
source(file.path(paste0(functionScriptDir,"07-Card_Data_Treatment.R")))
source(file.path(paste0(functionScriptDir,"99-Output_Export.R")))

# Create all the directories where results will be written
PathToLastDirs = 
  createResultDirectories(ResultDir, MtgFormat, Beginning, End, EventType,
                          CsvResultDir, PictureResultDir, TextResultDir)

# # Import MTG JSON card data
# mtgJsonData = bind_rows(jsonlite::fromJSON(mtgJsonFile)$data, .id = "cardName")

#Import tournament raw data
RawData = jsonlite::fromJSON(TournamentResultFile)[[1]] 
Beginning = min(RawData$Date)
End = max(RawData$Date)
EventType = EventTypes[2]
MtgFormat = MtgFormats[4]

tournamentDf = generate_df(
  RawData, EventType, MtgFormat, TournamentResultFile, Beginning, End) %>%
  filter(Meta != "StartOfMtgoData")

#' Return the meta share of the topX most played cards 
#' (except from basic, fetch, shock)
#'
#' @param df the dataframe generated by generate_df() 
#'
#' @return a dataframe with the share of the topX most played cards
#' @export
#'
#' @examples
get_highest_card_share = function(df,X){
  
  # # For development only
  # df = tournamentDf
  
  Mainboards = lapply(df$Mainboard, function(MD){ MD$CardName })
  Sideboards = sapply(df$Sideboard, function(SB){ SB$CardName })
  
  MainboardCards = unique(unlist(Mainboards))
  SideboardCards = unique(unlist(Sideboards))
  
  CommonLands = 
    c("Forest", "Island", "Mountain", "Plains", "Snow-Covered Forest", 
      "Snow-Covered Island", "Snow-Covered Mountain", "Snow-Covered Plains",
      "Snow-Covered Swamp", "Snow-Covered Wastes", "Swamp", "Wastes",
      "Arid Mesa","Bloodstained Mire","Flooded Strand","Marsh Flats",
      "Misty Rainforest","Polluted Delta","Scalding Tarn","Verdant Catacombs",
      "Windswept Heath", "Wooded Foothills", "Blood Crypt","Breeding Pool",
      "Godless Shrine","Hallowed Fountain","Overgrown Tomb","Sacred Foundry",
      "Steam Vents","Stomping Ground","Temple Garden","Watery Grave")
  
  # Remove multiple values by list
  MainboardCards = setdiff(MainboardCards, CommonLands)
  SideboardCards = setdiff(SideboardCards, CommonLands)
  
  
  CardData = data.frame(Card.Name = unique(c(MainboardCards,SideboardCards)))
  
  # Identify in which decklist each card is
  CardDecklistsPresence = lapply(CardData$Card.Name, function(CardName){
    MDPresence = sapply(Mainboards, function(MD, name) {name %in% MD}, CardName)
    SBPresence = sapply(Sideboards, function(SB, name) {name %in% SB}, CardName)
    DecklistsPresence = (MDPresence | SBPresence)
    return(DecklistsPresence)
  })
  names(CardDecklistsPresence) = CardData$Card.Name
  
  # Count the number of decklists where each card is
  CardData$Decklist.Count = 
    sapply(CardDecklistsPresence, function(presenceInDecklists){n
      sum(presenceInDecklists)
    })
  CardData$Meta.Share = paste(round(100 * CardData$Decklist.Count / nrow(df), 
                                  digits = 2),"%")
  
  CardData = CardData[order(CardData$Decklist.Count, decreasing = TRUE),]

  CardData[c(1:X),c(1,3)]
}

apply_by_meta <- function(df, topX) {
  unique_metas <- unique(df$Meta)
  
  results <- lapply(unique_metas, function(meta) {
    print(meta)
    filtered_df <- df %>% filter(Meta == meta)
    result <- get_highest_card_share(filtered_df, topX)
    
    # Transformation en format long puis large
    result <- result %>%
      transformer_dataframe %>%
      mutate(Meta = meta, .before = Card.Name.1)
    
    result
  })
  
  bind_rows(results)
}

transformer_dataframe <- function(df) {
  
  # Convertir en vecteur
  vec <- as.vector(t(df))
  # Créer une matrice avec les données réorganisées
  mat <- matrix(vec, nrow = 1)
  # Convertir en dataframe
  df_final <- as.data.frame(mat)
  # Renommer les colonnes correctement
  colnames(df_final) <- paste0(rep(c("Card.Name.", "Meta.Share."), times = nrow(df)), rep(1:(nrow(df)), each = 2))
  df_final
}

# Application de la fonction
final_df <- apply_by_meta(tournamentDf,5)
View(final_df)

write.table(final_df, "Results/Modern_most_played_card_by_meta.csv", 
            row.names = FALSE, sep = ";")

filtered_df <- tournamentDf %>% filter(Meta == "PostBloomburrow")
result <- get_highest_card_share(filtered_df, 10)
result
