################################################################################
#####                  MTG Tournament Result Analysis                      #####
#####                           by AnaÃ«l Yahi                              #####
#####               based on data generated by Phelps-san                  #####
#####            https://github.com/Badaro/MTGOArchetypeParser             #####
################################################################################
#####                        05-Decklist_Analysis.R                        #####
##### Use this file to import functions that analyse decklists of a given  #####
##### archetype to provide the best and average ones.                      #####
################################################################################

# For development
# df = tournamentDf
# deckName = "Creativity"

#' Round to the nearest number
#'
#' @param x the number to round
#' @param digits the number of digits to be rounded to
#'
#' @return the nearest number to x with digits numbers after the comma
#' @export
#'
#' @examples
round2 = function(x, digits) {
  posneg = sign(x)
  z = abs(x)*10^digits
  z = z + 0.5 + sqrt(.Machine$double.eps)
  z = trunc(z)
  z = z/10^digits
  z*posneg
}

#' Get all the unique cards played in a given archetype and their data
#'
#' @param deckName a string with the name of the archetype to find
#' @param color a string with the color of the archetype to keep. Ex: "WUBRG"
#' If "All", doesn't filter by color.
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of cards played in the archetype in a dataframe, with data
#' on their presence and win rate, split between MD and SB
#' @export
#'
#' @examples
get_archetype_card_data = function(deckName, color, df){
  
  # # For development only
  # deckName = "Hammer Time"
  # color = "W"
  # df = tournamentDf
  
  # Filter to keep the data of a given archetype in a chosen color
  archetypeDf = df[df$Archetype$Archetype == deckName,]
  if(color!="All"){
    archetypeDf = archetypeDf[archetypeDf$Archetype$Color == color,]
  }
  
  # Get the card list of each deck: card name and the corresponding number of 
  # copies, both for mainboard (MD = maindeck) and sideboard (SB)
  cardNamesMD = unlist(lapply(archetypeDf$Mainboard, 
                              function(archetypeBoardVector) 
                                {archetypeBoardVector$CardName}))
  cardCountsMD = unlist(lapply(archetypeDf$Mainboard,  
                               function(archetypeBoardVector) 
                               {archetypeBoardVector$Count}))
  winCountsMD = unlist(mapply(function(MDCards, numberWins)
    {rep(numberWins,length(MDCards$CardName))}, 
                              archetypeDf$Mainboard, archetypeDf$Wins))
  lossCountsMD = unlist(mapply(function(MDCards, numberLosses)
  {rep(numberLosses,length(MDCards$CardName))}, 
  archetypeDf$Mainboard, archetypeDf$Losses))
  
  cardNamesSB = unlist(lapply(archetypeDf$Sideboard, 
                              function(archetypeBoardVector) 
                              {archetypeBoardVector$CardName}))
  cardCountsSB = unlist(lapply(archetypeDf$Sideboard,  
                               function(archetypeBoardVector) 
                               {archetypeBoardVector$Count}))
  winCountsSB = unlist(mapply(function(SBCards, numberWins)
  {rep(numberWins,length(SBCards$CardName))}, 
  archetypeDf$Sideboard, archetypeDf$Wins))
  lossCountsSB = unlist(mapply(function(SBCards, numberLosses)
  {rep(numberLosses,length(SBCards$CardName))}, 
  archetypeDf$Sideboard, archetypeDf$Losses))
  
  # Regroup the data in dataframes
  MDCards = data.frame(Card.Name = cardNamesMD, 
                       Copies.In.MD = cardCountsMD,
                       Wins.In.MD = winCountsMD,
                       Losses.In.MD = lossCountsMD)
  SBCards = data.frame(Card.Name = cardNamesSB, 
                       Copies.In.SB = cardCountsSB,
                       Wins.In.SB = winCountsSB,
                       Losses.In.SB = lossCountsSB)
  
  # Keep only one row by different card, summing their copies, wins and defeats
  MDCardsAggregate = aggregate(. ~ Card.Name, data = MDCards, sum)
  SBCardsAggregate = aggregate(. ~ Card.Name, data = SBCards, sum)
  
  # Create a dataframe listing all the different cards in the archetype, 
  # including the number of copies that are ran of each
  archetypeCardData = 
    merge(MDCardsAggregate, SBCardsAggregate, by = "Card.Name", all = TRUE)
  archetypeCardData[is.na(archetypeCardData)] = 0
  archetypeCardData$Copies.In.Decks = archetypeCardData$Copies.In.MD +
    archetypeCardData$Copies.In.SB
  archetypeCardData$Wins.In.Decks = 
    archetypeCardData$Wins.In.MD + 
    archetypeCardData$Wins.In.SB
  archetypeCardData$Losses.In.Decks = 
    archetypeCardData$Losses.In.MD + 
    archetypeCardData$Losses.In.SB

  archetypeCardData$WR.In.MD = 
    round(archetypeCardData$Wins.In.MD /
            (archetypeCardData$Wins.In.MD + 
               archetypeCardData$Losses.In.MD) * 100, digits = 2)
  archetypeCardData$Lower.CI.WR.In.MD = 
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                      p=0.5,alternative = "two.sided", 
                      conf.level=CIPercent)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.MD,
    archetypeCardData$Losses.In.MD)
  archetypeCardData$Upper.CI.WR.In.MD =  
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=CIPercent)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.MD,
    archetypeCardData$Losses.In.MD)
  
  archetypeCardData$WR.In.SB = 
    round(archetypeCardData$Wins.In.SB /
            (archetypeCardData$Wins.In.SB + 
               archetypeCardData$Losses.In.SB) * 100, digits = 2)
  archetypeCardData$Lower.CI.WR.In.SB = 
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=CIPercent)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.SB,
    archetypeCardData$Losses.In.SB)
  archetypeCardData$Upper.CI.WR.In.SB =  
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=CIPercent)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.SB,
    archetypeCardData$Losses.In.SB)
  
  archetypeCardData$WR.In.Decks = 
    round(archetypeCardData$Wins.In.Decks /
            (archetypeCardData$Wins.In.Decks + 
               archetypeCardData$Losses.In.Decks) * 100, digits = 2)
  archetypeCardData$Lower.CI.WR.In.Decks = 
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=CIPercent)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.Decks,
    archetypeCardData$Losses.In.Decks)
  archetypeCardData$Upper.CI.WR.In.Decks =  
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=CIPercent)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.Decks,
    archetypeCardData$Losses.In.Decks)

  archetypeCardData$Number.Of.MD = 
    sapply(archetypeCardData$Card.Name, 
           function(currentCard) 
           {nrow(MDCards[MDCards$Card.Name == currentCard,])})
  archetypeCardData$Number.Of.SB  = 
    sapply(archetypeCardData$Card.Name, 
           function(currentCard) 
           {nrow(SBCards[SBCards$Card.Name == currentCard,])})
  
  archetypeCardData$Share.Of.MD = 
    round(archetypeCardData$Number.Of.MD / nrow(archetypeDf) * 100, 
          digits = 2)
  archetypeCardData$Share.Of.SB  = 
    round(archetypeCardData$Number.Of.SB / nrow(archetypeDf) * 100, 
          digits = 2)
  
  
  archetypeCardData$Average.MD.Count.If.Present =
    round(sapply(archetypeCardData$Card.Name,
           function(currentCard) 
             {mean(MDCards[MDCards$Card.Name == currentCard,]$Copies.In.MD)}), 
          digits = 2)
  archetypeCardData$Average.SB.Count.If.Present =
    round(sapply(archetypeCardData$Card.Name,
           function(currentCard)
           {mean(SBCards[SBCards$Card.Name == currentCard,]$Copies.In.SB)}), 
          digits = 2)
  
  archetypeCardData$Most.Common.MD.Count = 
    lapply(archetypeCardData$Card.Name, function(cardName) 
        {mostPresentCountsMD = as.numeric(names(which.max(
          table(MDCards[MDCards$Card.Name == cardName,]$Copies.In.MD))));
      ifelse(length(mostPresentCountsMD)>0, min(mostPresentCountsMD),0)})
    
  archetypeCardData$Most.Common.SB.Count = 
    lapply(archetypeCardData$Card.Name, function(cardName) 
    {mostPresentCountsSB = as.numeric(names(which.max(
      table(SBCards[SBCards$Card.Name == cardName,]$Copies.In.SB))));
    ifelse(length(mostPresentCountsSB)>0,min(mostPresentCountsSB),0)})
  
  archetypeCardData[is.na(archetypeCardData)] = 0
  
  archetypeCardData = archetypeCardData %>%
    select(c("Card.Name","Share.Of.MD","Share.Of.SB","WR.In.MD","WR.In.SB"), everything())
  
  return(archetypeCardData)
}

#' Get the data of all the unique cards based on their number of copies
#'
#' @param deckName a string with the name of the archetype to find
#' @param color a string with the color of the archetype to keep. Ex: "WUBRG"
#' If "All", doesn't filter by color.
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of cards played in the archetype in a dataframe, depending
#' on the number of copues, with data #' on their presence and win rate, split
#' between MD and SB
#' 
#' @export
#'
#' @examples
get_archetype_card_data_by_count = function(deckName, color, df){
  
  # # For development only
  # deckName = "Hammer Time"
  # color = "W"
  # df = tournamentDf
  # color = optimizedColor
  
  # Filter to keep the data of a given archetype in a chosen color
  archetypeDf = df[df$Archetype$Archetype == deckName,]
  if(color!="All"){
    archetypeDf = archetypeDf[archetypeDf$Archetype$Color == color,]
  }
  
  # Get the card list of each deck: card name and the corresponding number of 
  # copies, both for mainboard (MD = maindeck) and sideboard (SB)
  cardNamesMD = unlist(lapply(archetypeDf$Mainboard, 
                              function(archetypeBoardVector) 
                              {archetypeBoardVector$CardName}))
  cardCountsMD = unlist(lapply(archetypeDf$Mainboard,  
                               function(archetypeBoardVector) 
                               {archetypeBoardVector$Count}))
  cardCountsAndNamesMD = paste(cardCountsMD, cardNamesMD)
  
  winCountsMD = c(unlist(mapply(function(MDCards, numberWins)
  {rep(numberWins,length(MDCards$CardName))}, 
  archetypeDf$Mainboard, archetypeDf$Wins)))
  
  lossCountsMD = c(unlist(mapply(function(MDCards, numberLosses)
  {rep(numberLosses,length(MDCards$CardName))}, 
  archetypeDf$Mainboard, archetypeDf$Losses)))
  
  
  
  cardNamesSB = unlist(lapply(archetypeDf$Sideboard, 
                              function(archetypeBoardVector) 
                              {archetypeBoardVector$CardName}))
  cardCountsSB = unlist(lapply(archetypeDf$Sideboard,  
                               function(archetypeBoardVector) 
                               {archetypeBoardVector$Count}))
  
  cardCountsAndNamesSB = paste(cardCountsSB, cardNamesSB)
  
  winCountsSB = c(unlist(mapply(function(SBCards, numberWins)
  {rep(numberWins,length(SBCards$CardName))}, 
  archetypeDf$Sideboard, archetypeDf$Wins)))
  
  lossCountsSB = c(unlist(mapply(function(SBCards, numberLosses)
  {rep(numberLosses,length(SBCards$CardName))}, 
  archetypeDf$Sideboard, archetypeDf$Losses)))
  
  # Regroup the data in dataframes
  MDCards = data.frame(Count.and.Name = cardCountsAndNamesMD,
                       Wins.In.MD = winCountsMD,
                       Losses.In.MD = lossCountsMD)
  SBCards = data.frame(Count.and.Name = cardCountsAndNamesSB,
                       Wins.In.SB = winCountsSB,
                       Losses.In.SB = lossCountsSB)
  
  # Keep only one row by different card, summing their copies, wins and defeats
  MDCardsAggregate = aggregate(. ~ Count.and.Name, data = MDCards, sum)
  SBCardsAggregate = aggregate(. ~ Count.and.Name, data = SBCards, sum)
  
  # Create a dataframe listing all the different cards in the archetype, 
  # including the number of copies that are ran of each
  archetypeCardData = 
    merge(MDCardsAggregate, SBCardsAggregate, by = "Count.and.Name", all = TRUE)
  archetypeCardData[is.na(archetypeCardData)] = 0
  archetypeCardData$Wins.In.Decks = 
    archetypeCardData$Wins.In.MD + 
    archetypeCardData$Wins.In.SB
  archetypeCardData$Losses.In.Decks = 
    archetypeCardData$Losses.In.MD + 
    archetypeCardData$Losses.In.SB
  
  archetypeCardData$WR.In.MD = 
    round(archetypeCardData$Wins.In.MD /
            (archetypeCardData$Wins.In.MD + 
               archetypeCardData$Losses.In.MD) * 100, digits = 2)
  archetypeCardData$Lower.CI.WR.In.MD = 
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                                       p=0.5,alternative = "two.sided", 
                                       conf.level=CIPercent)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.MD,
    archetypeCardData$Losses.In.MD)
  archetypeCardData$Upper.CI.WR.In.MD =  
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                                       p=0.5,alternative="two.sided", 
                                       conf.level=CIPercent)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.MD,
    archetypeCardData$Losses.In.MD)
  
  archetypeCardData$WR.In.SB = 
    round(archetypeCardData$Wins.In.SB /
            (archetypeCardData$Wins.In.SB + 
               archetypeCardData$Losses.In.SB) * 100, digits = 2)
  archetypeCardData$Lower.CI.WR.In.SB = 
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                                       p=0.5,alternative="two.sided", 
                                       conf.level=CIPercent)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.SB,
    archetypeCardData$Losses.In.SB)
  archetypeCardData$Upper.CI.WR.In.SB =  
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                                       p=0.5,alternative="two.sided", 
                                       conf.level=CIPercent)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.SB,
    archetypeCardData$Losses.In.SB)
  
  archetypeCardData$WR.In.Decks = 
    round(archetypeCardData$Wins.In.Decks /
            (archetypeCardData$Wins.In.Decks + 
               archetypeCardData$Losses.In.Decks) * 100, digits = 2)
  archetypeCardData$Lower.CI.WR.In.Decks = 
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                                       p=0.5,alternative="two.sided", 
                                       conf.level=CIPercent)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.Decks,
    archetypeCardData$Losses.In.Decks)
  archetypeCardData$Upper.CI.WR.In.Decks =  
    mapply(function(Wins,NLosses)
    {ifelse(NLosses>0,round(binom.test(Wins, Wins + NLosses, 
                                       p=0.5,alternative="two.sided", 
                                       conf.level=CIPercent)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.Decks,
    archetypeCardData$Losses.In.Decks)
  
  archetypeCardData$Number.Of.MD = 
    sapply(archetypeCardData$Count.and.Name, 
           function(currentCard) 
           {nrow(MDCards[MDCards$Count.and.Name == currentCard,])})
  archetypeCardData$Number.Of.SB  = 
    sapply(archetypeCardData$Count.and.Name, 
           function(currentCard) 
           {nrow(SBCards[SBCards$Count.and.Name == currentCard,])})
  
  archetypeCardData$Share.Of.MD = 
    round(archetypeCardData$Number.Of.MD / nrow(archetypeDf) * 100, 
          digits = 2)
  archetypeCardData$Share.Of.SB  = 
    round(archetypeCardData$Number.Of.SB / nrow(archetypeDf) * 100, 
          digits = 2)
  
  archetypeCardData$Average.MD.Count.If.Present =
    round(sapply(archetypeCardData$Count.and.Name,
                 function(currentCard) 
                 {mean(MDCards[MDCards$Count.and.Name == currentCard,]$Copies.In.MD)}), 
          digits = 2)
  archetypeCardData$Average.SB.Count.If.Present =
    round(sapply(archetypeCardData$Count.and.Name,
                 function(currentCard)
                 {mean(SBCards[SBCards$Count.and.Name == currentCard,]$Copies.In.SB)}), 
          digits = 2)
  
  archetypeCardData$Most.Common.MD.Count = 
    lapply(archetypeCardData$Count.and.Name, function(cardName) 
    {mostPresentCountsMD = as.numeric(names(which.max(
      table(MDCards[MDCards$Count.and.Name == cardName,]$Copies.In.MD))));
    ifelse(length(mostPresentCountsMD)>0, min(mostPresentCountsMD),0)})
  
  archetypeCardData$Most.Common.SB.Count = 
    lapply(archetypeCardData$Count.and.Name, function(cardName) 
    {mostPresentCountsSB = as.numeric(names(which.max(
      table(SBCards[SBCards$Count.and.Name == cardName,]$Copies.In.SB))));
    ifelse(length(mostPresentCountsSB)>0,min(mostPresentCountsSB),0)})
  
  archetypeCardData$Card.Count = 
    as.numeric(str_extract(archetypeCardData$Count.and.Name, "^[0-9]+"))
  archetypeCardData$Card.Name = 
    str_trim(str_replace(archetypeCardData$Count.and.Name, "^[0-9]+", ""))
  
  archetypeCardData[is.na(archetypeCardData)] = 0
  
  archetypeCardData = archetypeCardData %>%
    select(c("Count.and.Name","Share.Of.MD","Share.Of.SB","WR.In.MD","WR.In.SB"), everything())
  
  return(archetypeCardData)
}

#' Get the most played color combination for a given deck
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the most played color combination for a given archetype as a string
#' @export
#'
#' @examples
get_archetype_most_common_colors = function(deckName, df){
  return(names(which.max(
    table(df[df$Archetype$Archetype == deckName,]$Archetype$Color))))
}

#' Get all the color combinations for a given deck
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return all the color combinations for a given archetype as a vectof
#' @export
#'
#' @examples
get_archetype_colors = function(deckName, df){
  return(table(df[df$Archetype$Archetype == deckName,]$Archetype$Color))
}

# # For development
# deckName = "Creativity"
# get_archetype_colors(deckName, df)
# archetypeMainColor = get_archetype_most_common_colors(deckName, df)
# color = "UBRG" 

#' Get the average decklist for an archetype in a specific color combination
#'
#' @param deckName a string with the name of the archetype to find
#' @param color a string with the color of the archetype to keep. Ex: "WUBRG"
#' @param df the dataframe returned by generate_df()
#'
#' @return a dataframe with the card names and their count in the archetype
#' @export
#'
#' @examples
get_average_decklist = function(deckName, color, df){
  
  # Filter to keep the data of a given archetype in a chosen color
  archetypeDf = df[df$Archetype$Archetype == deckName,]
  archetypeDf = archetypeDf[archetypeDf$Archetype$Color == color,]
  
  # Get the list of unique cards played in that archetype and the associated
  # performance data
  archetypeCardData = 
    get_archetype_card_data(deckName, color, df)
  
  # Minimum value of the most present number of cards in MD
  averageCardTotalMD = min(as.numeric(names(which.max(table(unlist(
    lapply(archetypeDf$Mainboard, function(archetypeBoardVector) 
      {sum(archetypeBoardVector$Count)})))))))
  
  averageMaindeck = data.frame(CardNamesMD = character(),
                               CardCountMD = numeric(),
                               AverageCountMD = numeric(),
                               ShareMD = numeric())
  
  while(sum(averageMaindeck$CardCountMD) < averageCardTotalMD){
    mostPresentShare = max(archetypeCardData$Share.Of.MD)
    mostPresentCards = 
      archetypeCardData[archetypeCardData$Share.Of.MD == 
                          mostPresentShare,]
    archetypeCardData = archetypeCardData[
        archetypeCardData$Share.Of.MD != mostPresentShare,]
    
    while(nrow(mostPresentCards)>0 && 
          sum(averageMaindeck$CardCountMD) < averageCardTotalMD){
      averageMaindeck[nrow(averageMaindeck) + 1,] = 
        c(mostPresentCards[1,]$Card.Name, 
          mostPresentCards[1,]$Most.Common.MD.Count, 
          mostPresentCards[1,]$Average.MD.Count.If.Present,
          mostPresentCards[1,]$Share.Of.MD)
      mostPresentCards = mostPresentCards[-1,]
      averageMaindeck$CardCountMD =  round2(
        as.numeric(averageMaindeck$CardCountMD),0)
    }
    while(sum(averageMaindeck$CardCountMD) > averageCardTotalMD){
      if(averageMaindeck[nrow(averageMaindeck),]$CardCountMD > 
         sum(averageMaindeck$CardCountMD) - averageCardTotalMD){
        averageMaindeck[nrow(averageMaindeck),]$CardCountMD = 
          averageMaindeck[nrow(averageMaindeck),]$CardCountMD - 
          (sum(averageMaindeck$CardCountMD) - averageCardTotalMD)
      }else{
        averageMaindeck = head(averageMaindeck, - 1)   
      }
    }
  }
  # # For development
  # sum(averageMaindeck$CardCountMD)
  
  averageCardTotalSB = 15
  
  averageSideboard = data.frame(CardNamesSB = character(),
                               CardCountSB = numeric(),
                               AverageCountSB = numeric(),
                               ShareSB = numeric())
  
  while(sum(averageSideboard$CardCountSB) < averageCardTotalSB){
    mostPresentShare = max(archetypeCardData$Share.Of.SB)
    mostPresentCards = 
      archetypeCardData[archetypeCardData$Share.Of.SB == 
                          mostPresentShare,]
    archetypeCardData = archetypeCardData[
      archetypeCardData$Share.Of.SB != mostPresentShare,]
    
    while(nrow(mostPresentCards)>0 && 
          sum(averageSideboard$CardCountSB) < averageCardTotalSB){
      averageSideboard[nrow(averageSideboard) + 1,] = 
        c(mostPresentCards[1,]$Card.Name, 
          mostPresentCards[1,]$Most.Common.SB.Count, 
          mostPresentCards[1,]$Average.SB.Count.If.Present,
          mostPresentCards[1,]$Share.Of.SB)
      mostPresentCards = mostPresentCards[-1,]
      averageSideboard$CardCountSB =  round2(
        as.numeric(averageSideboard$CardCountSB),0)
    }
    while(sum(averageSideboard$CardCountSB) > averageCardTotalSB){
      if(averageSideboard[nrow(averageSideboard),]$CardCountSB > 
         sum(averageSideboard$CardCountSB) - averageCardTotalSB){
        averageSideboard[nrow(averageSideboard),]$CardCountSB = 
          averageSideboard[nrow(averageSideboard),]$CardCountSB - 
          (sum(averageSideboard$CardCountSB) - averageCardTotalSB)
      }else{
        averageSideboard = head(averageSideboard, - 1)   
      }
    }
  }
  
  return(list(MainDeck = averageMaindeck, SideBoard = averageSideboard))
}

#' Get the presence and winrate of the archetype depending on the color 
#' combination
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return a data frame with the color, presence and winrate
#' @export
#'
#' @examples
get_archetype_data_by_color = function(deckName, df){
  archetypeColors = get_archetype_colors(deckName, df)
  colorResults = data.frame(archetypeColors)
  names(colorResults) = c("Colors","Presence")
  
  colorResults$Wins = mapply(function(color){
    archetypeDf = df[df$Archetype$Archetype == deckName,]
    archetypeDf = archetypeDf[archetypeDf$Archetype$Color == color,]
    
    sum(archetypeDf$Wins)
  },colorResults$Colors)
  
  colorResults$Defeats = mapply(function(color){
    archetypeDf = df[df$Archetype$Archetype == deckName,]
    archetypeDf = archetypeDf[archetypeDf$Archetype$Color == color,]
    
    sum(archetypeDf$Losses)
  },colorResults$Colors)
  
  colorResults$Winrate = mapply(function(wins, defeats){
    round(100*wins/(wins+defeats), digits = 2)
  },colorResults$Wins,colorResults$Defeats)
  
  colorResults$WRLower.Bound.of.CI.on.WR = mapply(FUN = function(wins, defeats){
    round(binom.test(wins, wins + defeats, p = 0.5, alternative = "two.sided", 
               conf.level = CIPercent)$conf.int[1] * 100, digits = 2)
  }, colorResults$Wins, colorResults$Defeats)
  
  # Return the most reliable winrate (best lower bound of the confidence interval)
  colorResults[order(colorResults$WRLower.Bound.of.CI.on.WR,decreasing=TRUE),]
}

#' Get the decklist optimized by lowest bound on the winrate for an archetype 
#' for the optimized color combination
#'
#' @param deckName a string with the name of the archetype to find
#' @param optimizedColor a string with the color of the archetype to keep. 
#' Ex: "WUBRG"
#' @param df the dataframe returned by generate_df()
#'
#' @return a dataframe with the card names and their count in the archetype
#' @export
#'
#' @examples
get_winrate_optimized_decklist = function(deckName, optimizedColor, df){
  # df = tournamentDf
  # deckName = archetypeName
  # Filter to keep the data of a given archetype in an optimized color based
  # on the lowest bound of confidence interval on the winrate
  archetypeDf = df[df$Archetype$Archetype == deckName,]
  # optimizedColor = get_archetype_data_by_color(deckName)$Colors[1]
  archetypeDf = archetypeDf[archetypeDf$Archetype$Color == optimizedColor,]
  
  # Optimize the number of cards in MD based on the lowest bound of confidence
  # interval on the winrate
  Total.Cards = unlist(
    lapply(archetypeDf$Mainboard, 
           function(archetypeBoardVector){
             sum(archetypeBoardVector$Count)
           }
    ))
  Total.Wins = archetypeDf$Wins
  Total.Defeats = archetypeDf$Losses
  
  deckCardCountData = data.frame(Total.Cards,Total.Wins,Total.Defeats)
  
  deckCardCountData = aggregate(. ~ Total.Cards, data=deckCardCountData, FUN=sum)
  
  deckCardCountData$Deck.Measured.Winrate = mapply(function(wins, defeats){
    round(100*wins/(wins+defeats), digits = 2)
  },deckCardCountData$Total.Wins,deckCardCountData$Total.Defeats)
  
  deckCardCountData$Deck.Lower.Bound.Winrate = mapply(FUN = function(wins, defeats){
    round(binom.test(wins, wins + defeats, p = 0.5, alternative = "two.sided", 
                     conf.level = CIPercent)$conf.int[1] * 100, digits = 2)
  }, deckCardCountData$Total.Wins,deckCardCountData$Total.Defeats)
  
  # # Used without the aggregate
  # linearRegression = lm(Deck.Measured.Winrate ~ Total.Cards, data = deckCardCountData)
  # summary(linearRegression)
  # # No correlation found for Cascade Beans on 2023/11/17 
  
  optimizedCardTotalMD = 
    deckCardCountData[order(deckCardCountData$Deck.Lower.Bound.Winrate,
                            decreasing=TRUE),]$Total.Cards[1]
  
  # Get the list of unique cards played in that archetype and the associated
  # performance data
  archetypeCardDataMB = 
    get_archetype_card_data_by_count(deckName, optimizedColor, df)
  
  archetypeCardDataSB = archetypeCardDataMB
    
  # Prepare the output structure
  optimizedMaindeck = data.frame(Card.Names.MD = character(),
                               Card.Count.MD = numeric(),
                               Lower.CI.WR.In.MD = numeric(),
                               Share.Of.MD = numeric())
  # i = 0
  
  while(sum(as.numeric(optimizedMaindeck$Card.Count.MD)) < optimizedCardTotalMD){
    # i = i+1
    # print(i)
    bestLBCI = max(archetypeCardDataMB$Lower.CI.WR.In.MD)
    bestLBCICard = 
      archetypeCardDataMB[archetypeCardDataMB$Lower.CI.WR.In.MD == bestLBCI,][1,]
    archetypeCardDataMB = archetypeCardDataMB[
      archetypeCardDataMB$Count.and.Name != bestLBCICard$Count.and.Name,]
    
    if(!(bestLBCICard[1,]$Card.Name %in% optimizedMaindeck$Card.Names.MD)){
      if(bestLBCICard$Card.Count + sum(as.numeric(optimizedMaindeck$Card.Count.MD)) <= 
         optimizedCardTotalMD){
        optimizedMaindeck[nrow(optimizedMaindeck) + 1,] = 
          c(bestLBCICard[1,]$Card.Name, 
            as.numeric(bestLBCICard[1,]$Card.Count), 
            bestLBCICard[1,]$Lower.CI.WR.In.MD,
            bestLBCICard[1,]$Share.Of.MD)
      }else{
        # Show after the comma how many copies there would be without the total 
        # limit of cards on the MD
        optimizedMaindeck[nrow(optimizedMaindeck) + 1,] = 
          c(bestLBCICard[1,]$Card.Name, 
            optimizedCardTotalMD - sum(as.numeric(optimizedMaindeck$Card.Count.MD))
            + 1/10*bestLBCICard[1,]$Card.Count,
            bestLBCICard[1,]$Lower.CI.WR.In.MD,
            bestLBCICard[1,]$Share.Of.MD)
      }
    }
  }
  # # For development
  # sum(optimizedMaindeck$CardCountMD)
  
  optimizedCardTotalSB = 15
  
  optimizedSideboard = data.frame(Card.Names.SB = character(),
                                  Card.Count.SB = numeric(),
                                  Lower.CI.WR.In.SB = numeric(),
                                  Share.Of.SB = numeric())
  
  while(sum(as.numeric(optimizedSideboard$Card.Count.SB)) < optimizedCardTotalSB){
    bestLBCI = max(archetypeCardDataSB$Lower.CI.WR.In.SB)
    bestLBCICard = 
      archetypeCardDataSB[archetypeCardDataSB$Lower.CI.WR.In.SB == bestLBCI,][1,]
    archetypeCardDataSB = archetypeCardDataSB[
      archetypeCardDataSB$Count.and.Name != bestLBCICard$Count.and.Name,]
    
    if(!(bestLBCICard[1,]$Card.Name %in% optimizedMaindeck$Card.Names.SB)){
      if(bestLBCICard$Card.Count + sum(as.numeric(optimizedSideboard$Card.Count.SB)) <= 
         optimizedCardTotalSB){
        optimizedSideboard[nrow(optimizedSideboard) + 1,] = 
          c(bestLBCICard[1,]$Card.Name, 
            as.numeric(bestLBCICard[1,]$Card.Count), 
            bestLBCICard[1,]$Lower.CI.WR.In.SB,
            bestLBCICard[1,]$Share.Of.SB)
      }else{
        # Show after the comma how many copies there would be without the total 
        # limit of cards on the SB
        optimizedSideboard[nrow(optimizedSideboard) + 1,] = 
          c(bestLBCICard[1,]$Card.Name, 
            optimizedCardTotalSB - sum(as.numeric(optimizedSideboard$Card.Count.SB)) 
            + 1/10*bestLBCICard[1,]$Card.Count,
            bestLBCICard[1,]$Lower.CI.WR.In.SB,
            bestLBCICard[1,]$Share.Of.SB)
      }
    }
  }
  
  optimizedMaindeck$Card.Count.and.Name.MD = 
    paste(optimizedMaindeck$Card.Count.MD, optimizedMaindeck$Card.Names.MD)
  optimizedSideboard$Card.Count.and.Name.SB = 
    paste(optimizedSideboard$Card.Count.SB, optimizedSideboard$Card.Names.SB)
  
  optimizedMaindeckText = paste(optimizedMaindeck$Card.Count.and.Name.MD, collapse = "\n")
  optimizedSideboardText = paste(optimizedSideboard$Card.Count.and.Name.SB, collapse = "\n")
  optimizedDeckText = paste0(optimizedMaindeckText,"\n\n",optimizedSideboardText, "\n\n")
  cat(optimizedDeckText)
  
  return(list(MainDeck = optimizedMaindeck, SideBoard = optimizedSideboard))
}
