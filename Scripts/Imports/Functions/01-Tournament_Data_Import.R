################################################################################
#####                  MTG Tournament Result Analysis                      #####
#####                           by AnaÃ«l Yahi                              #####
#####               based on data generated by Phelps-san                  #####
#####            https://github.com/Badaro/MTGOArchetypeParser             #####
################################################################################
#####                     02-Tournament_Data_Import.R                      #####
##### Use this file to import the tournament data from the JSON files      #####
##### generated by Phelps-san's program, and run simple getters.           #####
################################################################################

# install.packages("jsonlite")
# install.packages("readr")
# install.packages("devtools")
library("jsonlite")
library("readr")
library("devtools")

#' Structure a MTGO Preliminary dataset
#' 
#' Get the raw data of MTGO Preliminaries results, then add columns for its
#' treatment based on the specific structure of those results. 
#' Works for old and new Preliminary results (5 or 4 rounds).
#'
#' @param PrelimData a dataset generated by the code of 
#' generate_df() before the final if based on the EventType variable, and 
#' updated to keep only the MTGO Preliminary results
#'
#' @return an updated dataset with new columns for treatment:
#' 
#' - NRounds: the number of rounds, based on the score in the Result column
#' 
#' - NWins: the number of victories, dividing the number of points by 3
#' 
#' - NDefeats: the number of losses, by subtracting the number of victories to
#' the number of matches played
#' 
#' - NDraws: the number of draws, automatically 0 (added for compatibility
#' with other datasets during the analysis and binding)
#' 
#' - T8Points: automatically 0 (added for compatibility with other datasets 
#' during the analysis and binding)
#' 
#' - T8Defeats: automatically 0 (added for compatibility with other datasets 
#' during the analysis and binding)
#' 
#' @export
#'
#' @examples
generate_Prelim_Data = function(prelimData) {
  # Compute the number of rounds in each event for the preliminaries
  if (nrow(prelimData) >= 1) {
    prelimData$NRounds = rep(0,nrow(prelimData))
    conditionOldPrelims = prelimData$Result == "5-0" |
      prelimData$Result == "4-1" |
      prelimData$Result == "3-2"
    
    prelimData$NRounds = ifelse(conditionOldPrelims,5,4)
  }
  
  # Compute the number of defeats of each deck in Preliminaries -
  # number of rounds minus the number of points/3 (3 pts earned by win)
  prelimData$NWins = prelimData$Points / 3
  prelimData$NDraws = rep(0, nrow(prelimData)) # for merge with Full Meta Events
  prelimData$NDefeats = prelimData$NRounds - prelimData$Points / 3
  
  # Add top8 columns for merge with swiss round events
  prelimData$T8Points = rep(0, nrow(prelimData))
  prelimData$T8Defeats = rep(0, nrow(prelimData))
  prelimData$T8Matches = rep(0, nrow(prelimData))
  
  return(prelimData)
}

#' Structure a swiss rounds + top8 dataset
#' 
#' Get the raw data of MTG tournaments results, based on swiss rounds + top8,
#' then add columns for its treatment based on the specific structure of those 
#' results. 
#'
#' @param tournamentData a dataset generated by the code of 
#' generate_df() before the final if based on the EventType variable, and 
#' updated to remove all the MTGO Preliminary results.
#'
#' @return an updated dataset with new columns for treatment:
#' 
#' - NRounds: the number of rounds, based on an extrapolation of the points in 
#' the standings, or the sum of matches played if available in the matchup data
#' 
#' - NWins: the number of victories, by dividing the points by 3 in the 
#' standings, or by summing match victories if available in the matchup data
#' (a match victory is identified if there are strictly more game victories than
#' game losses)
#' 
#' - NDefeats: the number of losses, by subtracting the number of victories to
#' the number of matches played, or summing match losses if available in the
#' matchup data (a match loss is identified if there are strictly more game
#' losses than game victories)
#' 
#' - NDraws: the number of draws, based on the rest of the euclidean division
#' by 3 of the score (but it doesn't work well for 3 draws, unless compared
#' with the total number of rounds - the function doesn't do it yet 
#' since for the tournaments without match up data, there shouldn't be draws,
#' as those are MTGO results), or on the sum of match draws if available in 
#' the matchup data (a match draws is identified if there are as many game
#' losses as game victories)
#' 
#' - T8Points: 9 (3 victories) if 1st place, 6 if 2nd place, 3 if 3rd or 4th
#' place, 0 otherwise
#' 
#' - T8Defeats: 1 defeat if between 2nd to 8th place, 0 otherwise
#' 
#' @export
#'
#' @examples
generate_Tournament_Data = function(tournamentData) {
  
  # Compute the number of rounds in each event .
  # Divide the maximum number of points in swiss to get the result.
  # If more than 1 player has the maximum of points, then it is likely that
  # there is not any player at x-0, so you add 1 to the result
  
  listEvents = unique(tournamentData$TournamentName)
  nRoundsVec = c()
  if (length(listEvents) >= 1) {
    for (event in listEvents) {
      eventData = subset(tournamentData, TournamentName == event)
      maxPoints = max(eventData$Points, na.rm = TRUE)
      nPlayMaxPts = length(which(eventData$Points == maxPoints))
      nRounds = ifelse(nPlayMaxPts == 1,
                       maxPoints %/% 3,
                       1 + maxPoints %/% 3)
      nRoundsEvent = rep(nRounds, nrow(eventData))
      nRoundsVec = c(nRoundsVec, nRoundsEvent)
    }
  }
  tournamentData$NRounds = nRoundsVec
  
  # Compute the record of each deck in tournaments -
  # number of rounds minus the number of points/3 (3 pts earned by win)
  tournamentData$Points[is.na(tournamentData$Points)] = 0
  tournamentData$NWins = tournamentData$Points %/% 3
  tournamentData$NDraws = tournamentData$Points %% 3
  tournamentData$NDefeats = tournamentData$NRounds - 
    tournamentData$NWins - tournamentData$NDraws
  # Doesn't take draws in account if they are a multiple of 3
  # TODO : fix this drawback if tournaments without matchup data but a 
  # possibility of draws in the results arise. None currently.
  # The number of defeats might be required in the data if it happens.
  
  conditionMUNotNull = !sapply(tournamentData$Matchups, 
                               function(x) length(x) == 0 )
  
  for (i in (1:nrow(tournamentData))[conditionMUNotNull]) {
    
    tournamentDataI = tournamentData[i,]
    WinsI = tournamentDataI$Matchups[[1]]$Wins 
    DefeatsI = tournamentDataI$Matchups[[1]]$Losses 
    
    tournamentDataI$NWins = sum(WinsI > DefeatsI)
    
    tournamentDataI$NDefeats = sum(WinsI < DefeatsI)
    
    tournamentDataI$NDraws = sum(WinsI == DefeatsI)
    
    tournamentData[i,] = tournamentDataI
  }
  
  # Review the relevance of the computation of the number of rounds
  conditionRoundsDifferentFromScore = tournamentData$NRounds !=
    tournamentData$NWins + tournamentData$NDraws + tournamentData$NDefeats
  
  tournamentData[conditionRoundsDifferentFromScore,]$NRounds =
    tournamentData[conditionRoundsDifferentFromScore,]$NWins + 
    tournamentData[conditionRoundsDifferentFromScore,]$NDraws + 
    tournamentData[conditionRoundsDifferentFromScore,]$NDefeats
  
  #Add top8 points: 3*3 to 1st, 3*2 to 2nd, 3*1 to 3rd and 4th, none to others
  
  ConditionTop1 = tournamentData$NumericResult == 1
  ConditionTop2 = tournamentData$NumericResult == 2
  ConditionTop4 = tournamentData$NumericResult == 3 | 
    tournamentData$NumericResult == 4
  
  tournamentData$T8Points = ifelse(ConditionTop1,9,
                                   ifelse(ConditionTop2,6,
                                          ifelse(ConditionTop4,3,0)))
  
  #Add top8 defeats: 0 for the winner, 1 for the others
  tournamentData$T8Defeats = rep(0, nrow(tournamentData))
  
  #Add the number of matches played in top8: 3 in final, 2 in semi final, 1 in
  # quarterfinal
  if (length(listEvents) >= 1) {
    conditionTop8Not1 = tournamentData$NumericResult >= 2 &
      tournamentData$NumericResult <= 8
    tournamentData$T8Defeats = ifelse(conditionTop8Not1,
                                      tournamentData$T8Defeats+1,
                                      tournamentData$T8Defeats)
    
    ConditionTop2 = tournamentData$NumericResult <= 2
    ConditionTop4 = tournamentData$NumericResult == 3 | 
      tournamentData$NumericResult ==4
    ConditionTop8 = tournamentData$NumericResult <= 8 & 
      tournamentData$NumericResult >=4
    tournamentData$T8Matches = ifelse(ConditionTop2,3,
                                      ifelse(ConditionTop4,2,
                                             ifelse(ConditionTop8,1,0)))
  }
  
  return(tournamentData)
}

#' Import and clean tournament data
#'
#' @param eventType the category of events to keep in the data. It can be:
#' Event type:
#' All sources = Everything (except MTGO Leagues - for any filter)
#' All Events Top32 = Only events with a top32 (aka not MTGO Preliminaries)
#' Full Meta Events = Only events with the full metagame available (not MTGO Official results)
#' ManaTraders = ManaTraders Series results
#' Paper Events Full Meta = Full esults from MTG Melee
#' Paper Events Top32 = Results of the top32 from MTG Melee
#' MTGO Official Competitions = Results from the MTGO website
#' MTGO Events Top32 = MTGO results with a top32 (so not Preliminaries)
#' MTGO Preliminaries = As per name
#' @param mtgFormat the format of the tournaments to keep
#' @param tournamentDataPath the path of the JSON file to import
#' @param beginning the earliest date to keep in the dataset
#' @param end the latest date to keep in the dataset
#'
#' @return a dataframe with the structure and elements you need for metagame 
#' analysis
#' 
#' @export
#'
#' @examples
generate_df = function(eventType, mtgFormat, tournamentDataPath, beginning, end) {
  setwd(rprojroot::find_rstudio_root_file())
  #Import raw data
  rawData = fromJSON(TournamentResultFile)[[1]]
  if (!mtgFormat == "All_Formats") {
    # probably filtered before with right use of the parser and import of a
    # correctly named file
    rawData = rawData[grep(pattern = mtgFormat, x = rawData$Tournament), ]
  }
  rawData$Date = as.Date(rawData$Date)
  rawData$Points = as.numeric(rawData$Points)
  
  #Select data for a specific period
  periodData = subset(rawData, Date >= as.Date(beginning) &
                        Date < as.Date(end))
  
  # Names and date don't allow the identification of an event on  their own, but
  # the combination of both can, hence the addition of another column for this
  # identification, with a more readable name than the file name column
  periodData$TournamentName = rep(NA, nrow(periodData))
  periodData$TournamentName = paste(periodData$Tournament,
                                    as.character(periodData$Date), sep =
                                      " ")
  periodData$Result[is.na(periodData$Result)] = 0
  
  # Remove the noise from leagues in case it wasn't done by the parser
  periodData = periodData[!grepl("League", periodData$Tournament),]
  
  # Make the final position easier to manipulate as a number 
  # (doesn't work for Prelims)
  periodData$NumericResult = parse_number(periodData$Result)
  
  # /!\ Some events only have a top32, or don't even have one (Preliminary)
  if (eventType == "All sources") {
    Top32Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    PrelimData = periodData[grep("Preliminary", periodData$Tournament),]
    df = rbind(generate_Tournament_Data(Top32Data),
               generate_Prelim_Data(PrelimData))
    
  } else if (eventType == "All Events Top32") {
    Top32Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    # Keep only the top32
    Top32Data = Top32Data[Top32Data$NumericResult <= 32, ]
    df = generate_Tournament_Data(Top32Data)
    # Keep only the top32 of all those events
    
  } else if (eventType == "Full Meta Events") {
    # Use data from Manatraders and MTG Melee, not the partial MTGO website
    MTData = periodData[grep("https://www.manatraders.com/webshop/personal/",
                             periodData$AnchorUri),]
    PaperData = periodData[grep("https://mtgmelee.com/Decklist/View/",
                                periodData$AnchorUri),]
    df = rbind(generate_Tournament_Data(MTData),
               generate_Tournament_Data(PaperData))
    
  } else if (eventType == "ManaTraders") {
    # Use data from Manatraders
    MTData = periodData[grep("https://www.manatraders.com/webshop/personal/",
                             periodData$AnchorUri),]
    df = generate_Tournament_Data(MTData)
    
  } else if (eventType == "Paper Events Full Meta") {
    # Use data from MTG Melee
    PaperData = periodData[grep("https://mtgmelee.com/Decklist/View/",
                                periodData$AnchorUri),]
    df = generate_Tournament_Data(PaperData)
    
  } else if (eventType == "Paper Events Top32") {
    # Use data from MTG Melee
    PaperData = periodData[grep("https://mtgmelee.com/Decklist/View/",
                                periodData$AnchorUri),]
    # Keep only the top32
    PaperData = PaperData[PaperData$NumericResult <= 32, ]
    df = generate_Tournament_Data(PaperData)
    
  } else{
    MTGOData = periodData[grep("https://www.mtgo.com/en/mtgo/decklist/",
                               periodData$AnchorUri),]
    
    if (eventType == "MTGO Official Competitions") {
      MTGOTop32Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      PrelimData = MTGOData[grep("Preliminary", MTGOData$Tournament),]
      df = rbind(generate_Tournament_Data(MTGOTop32Data),
                 generate_Prelim_Data(PrelimData))
      
    } else if (eventType == "MTGO Events Top32") {
      # MTGO tournaments with a top32, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOTop32Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      df = generate_Tournament_Data(MTGOTop32Data)
      
    } else if (eventType == "MTGO Preliminaries") {
      # Preliminaries only
      PrelimData = MTGOData[grep("Preliminary", MTGOData$Tournament),]
      df = generate_Prelim_Data(PrelimData)
      
    }
  }
  
  return(df)
}

#' Get conflicted archetype URL
#'
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of URL of archetypes with Conflicts
#' @export
#'
#' @examples
getConflictURL = function(df){
  return(df[startsWith(df$Archetype$Archetype,"Conflict")==TRUE,]$AnchorUri)
}

#' Get conflicted archetype names
#'
#' @param df the dataframe returned bygenerate_df()
#'
#' @return the list of names of archetypes with Conflicts
#' @export
#'
#' @examples
getConflictArchetype = function(df){
  return(df[startsWith(df$Archetype$Archetype,
                       "Conflict")==TRUE,]$Archetype$Archetype)
}

#' Get Unknown archetype URL
#'
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of URL of archetypes classified as Unknown
#' @export
#'
#' @examples
getUnknown = function(df){
  return(df[df$Archetype$Archetype=="Unknown",]$AnchorUri)
}

#' Get all URL of decks with a given card
#'
#' @param cardName a string with the name of the card to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of decks with a specific card in the data. 
#' Empty if nothing fits (wrong name or not in the data).
#' @export
#'
#' @examples
getURLofCard=function(cardName,df){
  archetypeURL = c()
  for (i in 1:nrow(df)){
    if (length(grep(cardName,df$Mainboard[[i]]$CardName)) + 
        length(grep(cardName,df$Sideboard[[i]]$CardName))>0){
      archetypeURL = c(archetypeURL,df$AnchorUri[[i]])
    }
  }
  return(archetypeURL)
}

#' Get all URL of decks of a given archetype
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the list URL of decks of a given archetype, provided in parameters.
#' Empty if nothing fits (wrong name or not in the data).
#' @export
#'
#' @examples
getURLofDeck=function(deckName,df){
  return(df[df$Archetype$Archetype==deckName,]$AnchorUri)
}

#' Get the URL of the deck with the most points for a given archetype
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the URL of the most successful deck of a given archetype.
#' Empty if nothing fits (wrong name or not in the data).
#' @export
#'
#' @examples
getBestDeck=function(deckName,df){
  df2=df[df$Archetype$Archetype==deckName,]
  if(nrow(df2)>0){
    df2=df2[df2$Points+df2$T8Points==max(df2$Points+df2$T8Points),]
  }
  return(df2$AnchorUri)
}


#' Matchup data between two given archetypes
#'
#' @param df the dataframe returned by generate_df()
#' @param arch1 a string with the name of the archetype compared to the other
#' @param arch2 a string with the name of the archetype as opponent of the arch1
#'
#' @return a vector with the number of wins and losses in that matchup.
#' @export
#'
#' @examples
get_matchup_data = function(df,arch1,arch2){
  winsArch1VS2 = 0
  lossesArch1VS2 = 0
  dfArch1 = df[df$Archetype$Archetype==arch1,]
  conditionMUNotNull = !sapply(dfArch1$Matchups, function(x) length(x) == 0 )
  for (i in (1:nrow(dfArch1))[conditionMUNotNull]){
    matchesI = dfArch1[i,]$Matchups[[1]]
    matchesArch1VS2 = matchesI[matchesI$OpponentArchetype == arch2,]
    
    WinsI = matchesArch1VS2$Wins 
    DefeatsI = matchesArch1VS2$Losses 
    
    winsArch1VS2 = winsArch1VS2 + sum(WinsI > DefeatsI)
    lossesArch1VS2 = lossesArch1VS2 + sum(WinsI < DefeatsI) 
  }
  
  return(c(Wins = winsArch1VS2, Losses = lossesArch1VS2))
}
