################################################################################
#####                  MTG Tournament Result Analysis                      #####
#####                           by AnaÃ«l Yahi                              #####
#####               based on data generated by Phelps-san                  #####
#####            https://github.com/Badaro/MTGOArchetypeParser             #####
################################################################################
#####                     01-Tournament_Data_Import.R                      #####
##### Use this file to import the tournament data from the JSON files      #####
##### generated by Phelps-san's program, and run simple getters.           #####
################################################################################

# install.packages("jsonlite")
library("jsonlite")

#' Import and clean tournament data
#'
#' @param eventType the category of events to keep in the data. It can be:
#' Event type:
#' All sources = Everything (except MTGO Leagues - for any filter)
#' All Events Top32 = Only events with a top32 (aka not MTGO Preliminaries)
#' Full Meta Events = Only events with the full metagame available (not MTGO Official results)
#' ManaTraders = ManaTraders Series results
#' Paper Events Full Meta = Full esults from MTG Melee
#' Paper Events Top32 = Results of the top32 from MTG Melee
#' MTGO Official Competitions = Results from the MTGO website
#' MTGO Events Top32 = MTGO results with a top32 (so not Preliminaries)
#' MTGO Preliminaries = As per name
#' @param mtgFormat the format of the tournaments to keep
#' @param tournamentDataPath the path of the JSON file to import
#' @param beginning the earliest date to keep in the dataset
#' @param end the latest date to keep in the dataset
#'
#' @return a dataframe with the structure and elements you need for metagame 
#' analysis
#' 
#' @export
#'
#' @examples
generate_df = function(rawData, eventType, mtgFormat, tournamentDataPath, 
                       beginning, end) {
  
  # For development only
  rawData = fromJSON(TournamentResultFile)[[1]]
  eventType = EventType
  mtgFormat = MtgFormat
  tournamentDataPath = TournamentResultFile
  beginning = Beginning
  end = End

  # if (!mtgFormat == "All_Formats") {
  #   # probably filtered before with right use of the parser and import of a
  #   # correctly named file
  #   # We might lose tournaments such as Grand Open Qualifiers otherwise,
  #   # especially with the automation of MTG Melee
  #   rawData = rawData[grep(pattern = mtgFormat, x = rawData$Tournament), ]
  # }
  rawData$Date = as.Date(rawData$Date)
  
  #Select data for a specific period
  periodData = subset(rawData, Date >= as.Date(beginning) &
                        Date < as.Date(end))
  periodData$Points = as.numeric(periodData$Points)
  
  # Names and date don't allow the identification of an event on  their own, but
  # the combination of both can, hence the addition of another column for this
  # identification, with a more readable name than the file name column
  periodData$TournamentName = paste(periodData$Tournament,
                                    as.character(periodData$Date), sep =
                                      " ")
  periodData$Result[is.na(periodData$Result)] = 0
  
  # Remove decks without associated results
  periodData = periodData[!periodData$Result == "",]
  
  # Make the final position easier to manipulate as a number 
  # (doesn't work for Prelims)
  periodData$NumericResult = parse_number(periodData$Result)
  
  # Turn results into numeric values
  periodData$Wins = as.numeric(periodData$Wins)
  periodData$Losses = as.numeric(periodData$Losses)
  periodData$Draws = as.numeric(periodData$Draws)
  # Remove decks without scores
  periodData = periodData[!is.na(periodData$Wins),]
  periodData = periodData[!is.na(periodData$Losses),]
  
  periodData$Matches = periodData$Wins + periodData$Losses + periodData$Draws
  
  # Remove the noise from leagues in case it wasn't done by the parser
  periodData = periodData[!grepl("League", periodData$Tournament),]
  # Remove the Team Trio events providing unusable data
  periodData = periodData[!grepl("Team", periodData$Tournament),]
  
  # /!\ Some events only have a top32, or don't even have one (Preliminary)
  if (eventType == EventTypes[1]) {
    # "1" = "All events"
    resultDf = periodData
    
  } else if (eventType == EventTypes[2]) {
    # "2" = "All events Top32"
    # Keep only the top32
    resultDf = periodData[periodData$NumericResult <= 32, ]
    
  } else if (eventType == EventTypes[3]) {
    # "3" = "All events Top8"
    resultDf = periodData[periodData$NumericResult <= 8, ]
    
  } else if (eventType == EventTypes[4]) {
    # "4" = "All events Top1"
    resultDf = periodData[periodData$NumericResult == 1, ]
    
  } else if (eventType == EventTypes[5]) {
    # "5" = "All events X-2 or better"
    # Keep only the X-2 and better
    resultDf = periodData[periodData$Losses <= 2, ]
    
  } else if (eventType == EventTypes[6]) {
    # "6" = "All events X-1 or better"
    resultDf = periodData[periodData$Losses <= 1, ]
    
  } else if (eventType == EventTypes[7]) {
    # "7" = "Events with MU Data"
    # Use data from Manatraders and MTG Melee, not the partial MTGO website
    MTData = periodData[grep(Manatraders_URL,
                             periodData$AnchorUri),]
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    resultDf = rbind(MTData,PaperData)
    
  } else if (eventType == EventTypes[8]) {
    #"8" = "ManaTraders"
    # Use data from Manatraders
    resultDf = periodData[grep(Manatraders_URL,
                             periodData$AnchorUri),]
    
  } else if (eventType == EventTypes[9]) {
    # "9" = "Paper Events"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    resultDf = PaperData
    
  } else if (eventType == EventTypes[10]) {
    # "10" = "Paper Events Top32"
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top32
    resultDf = PaperData[PaperData$NumericResult <= 32, ]
    
  } else if (eventType == EventTypes[11]) {
    # "11" = "Paper Events Top8"
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top8
    resultDf = PaperData[PaperData$NumericResult <= 8, ]
    
  } else if (eventType == EventTypes[12]) {
    # "12" = "Paper Events Top1"
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top1
    resultDf = PaperData[PaperData$NumericResult <= 1, ]
    
  } else if (eventType == EventTypes[13]) {
    # "13" = "Paper Events X-2 or better"
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top1
    resultDf = PaperData[PaperData$Losses <= 2, ]
    
  } else if (eventType == EventTypes[14]) {
    # "14" = "Paper Events X-1 or better"
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top1
    resultDf = PaperData[PaperData$Losses <= 1, ]
    
  } else{
    MTGOData = periodData[grep(MTGO_URL,
                               periodData$AnchorUri),]
    
    if (eventType == EventTypes[15]) {
      # "15" = "MTGO Events"
      resultDf = MTGOData
      
    } else if (eventType == EventTypes[16]) {
      # "16" = "MTGO Challenges and Qualifiers"
      # MTGO tournaments with a top8, so not Preliminaries (nor Leagues,
      # already filtered)
      resultDf = MTGOData[grepl("Qualifier|Challenge", MTGOData$Tournament),]
      
    } else if (eventType == EventTypes[17]) {
      # "17" = "MTGO Events Top8"
      # MTGO tournaments with a top8, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOTop8Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top8
      resultDf = MTGOTop8Data[MTGOTop8Data$NumericResult <= 8, ]
      
    } else if (eventType == EventTypes[18]) {
      # "18" = "MTGO Events Top1"
      # MTGO tournaments with a top8, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOTop1Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top8
      resultDf = MTGOTop1Data[MTGOTop1Data$NumericResult <= 1, ]
      
    } else if (eventType == EventTypes[19]) {
      # "19" = "MTGO Events X-2 or better"
      # MTGO tournaments with a top8, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOX2Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top8
      resultDf = MTGOX2Data[MTGOX2Data$Losses <= 2, ]
      
    } else if (eventType == EventTypes[20]) {
      # "20" = "MTGO Events X-1 or better"
      # MTGO tournaments with a top8, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOX1Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top1
      resultDf = MTGOX1Data[MTGOX1Data$Losses <= 1, ]
      
    } else if (eventType == EventTypes[21]) {
      # "21" = "MTGO Preliminaries"
      # Preliminaries only
      resultDf = MTGOData[grep("Preliminary", MTGOData$Tournament),]
    }
  }
  
  if(addColor){
    resultDf$Archetype$Archetype = 
      mapply(function(archetypeName, archetypeColor) {
        ifelse(archetypeName %in% c("Hammer Time", "Murktide", "Creativity",
                                    "Prowess", "Footfalls", "Burn", 
                                    "Living End", "Merfolk", "Grinding Breach",
                                    "Mill","Hardened Scales","Asmo Food",
                                    "Goryo Reanimator", "Breach Value", 
                                    "Affinity"),
               paste(archetypeColor, archetypeName),
               archetypeName
        )
      }, resultDf$Archetype$Archetype, resultDf$Archetype$Color)
  }
  
  # resultDf$Allboards = mapply(function(Mainboard, Sideboard){
  #   list(as.data.frame(rbindlist(list(Mainboard, Sideboard))[, lapply(.SD, sum, na.rm =T), by = CardName]))
  # }, resultDf$Mainboard, resultDf$Sideboard)
  
  return(resultDf)
}

