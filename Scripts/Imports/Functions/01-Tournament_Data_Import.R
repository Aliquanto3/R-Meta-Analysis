################################################################################
#####                  MTG Tournament Result Analysis                      #####
#####                           by AnaÃ«l Yahi                              #####
#####               based on data generated by Phelps-san                  #####
#####            https://github.com/Badaro/MTGOArchetypeParser             #####
################################################################################
#####                     02-Tournament_Data_Import.R                      #####
##### Use this file to import the tournament data from the JSON files      #####
##### generated by Phelps-san's program, and run simple getters.           #####
################################################################################

# install.packages("jsonlite")
# install.packages("readr")
# install.packages("devtools")
# install.packages("data.table")
library("jsonlite")
library("readr")
library("devtools")
library("data.table")

#' Structure a MTGO Preliminary dataset
#' 
#' Get the raw data of MTGO Preliminaries results, then add columns for its
#' treatment based on the specific structure of those results. 
#' Works for old and new Preliminary results (5 or 4 rounds).
#'
#' @param PrelimData a dataset generated by the code of 
#' generate_df() before the final if based on the EventType variable, and 
#' updated to keep only the MTGO Preliminary results
#'
#' @return an updated dataset with new columns for treatment:
#' 
#' - NRounds: the number of rounds, based on the score in the Result column
#' 
#' - Wins: the number of victories, dividing the number of points by 3
#' 
#' - Losses: the number of losses, by subtracting the number of victories to
#' the number of matches played
#' 
#' - Draws: the number of draws, automatically 0 (added for compatibility
#' with other datasets during the analysis and binding)
#' 
#' - T8Points: automatically 0 (added for compatibility with other datasets 
#' during the analysis and binding)
#' 
#' - T8Defeats: automatically 0 (added for compatibility with other datasets 
#' during the analysis and binding)
#' 
#' @export
#'
#' @examples
generate_Prelim_Data = function(prelimData) {
  # # For development only
  # prelimData = PrelimData
  # Compute the number of rounds in each event for the preliminaries
  prelimData$NRounds = rep(NA, nrow(prelimData))
  prelimEventList = unique(prelimData$TournamentFile)
  for (prelimEvent in prelimEventList){
    prelimEventData = prelimData[prelimData$TournamentFile == prelimEvent,]
    # No draws in Preliminaries, always 4 or 5 rounds, no matter the players
    prelimEventRoundNumber = prelimEventData$Wins[1] + prelimEventData$Losses[1]
    prelimData[prelimData$TournamentFile == prelimEvent,]$NRounds = 
      rep(prelimEventRoundNumber,nrow(prelimEventData))
  }
  
  # Add top8 columns for merge with swiss round events
  prelimData$T8Points = rep(0, nrow(prelimData))
  prelimData$T8Defeats = rep(0, nrow(prelimData))
  prelimData$T8Matches = rep(0, nrow(prelimData))
  
  return(prelimData)
}

#' Structure a swiss rounds + top8 dataset
#' 
#' Get the raw data of MTG tournaments results, based on swiss rounds + top8,
#' then add columns for its treatment based on the specific structure of those 
#' results. 
#'
#' @param tournamentData a dataset generated by the code of 
#' generate_df() before the final if based on the EventType variable, and 
#' updated to remove all the MTGO Preliminary results.
#'
#' @return an updated dataset with new columns for treatment:
#' 
#' - NRounds: the number of rounds, based on an extrapolation of the points in 
#' the standings, or the sum of matches played if available in the matchup data
#' 
#' - Wins: the number of victories, by dividing the points by 3 in the 
#' standings, or by summing match victories if available in the matchup data
#' (a match victory is identified if there are strictly more game victories than
#' game losses)
#' 
#' - Losses: the number of losses, by subtracting the number of victories to
#' the number of matches played, or summing match losses if available in the
#' matchup data (a match loss is identified if there are strictly more game
#' losses than game victories)
#' 
#' - Draws: the number of draws, based on the rest of the euclidean division
#' by 3 of the score (but it doesn't work well for 3 draws, unless compared
#' with the total number of rounds - the function doesn't do it yet 
#' since for the tournaments without match up data, there shouldn't be draws,
#' as those are MTGO results), or on the sum of match draws if available in 
#' the matchup data (a match draws is identified if there are as many game
#' losses as game victories)
#' 
#' - T8Points: 9 (3 victories) if 1st place, 6 if 2nd place, 3 if 3rd or 4th
#' place, 0 otherwise
#' 
#' - T8Defeats: 1 defeat if between 2nd to 8th place, 0 otherwise
#' 
#' @export
#'
#' @examples
generate_Tournament_Data = function(tournamentData) {
  
  # # For development only
  # tournamentData = MTGONonPrelimData
  # tournamentData = PaperData
  # tournamentData = periodData
  
  tournamentData = tournamentData[!is.na(tournamentData$Points),]
  
  # Compute the number of rounds based on the MTR
  listEvents = unique(tournamentData$TournamentName)
  nRoundsVec = c()
  for (event in listEvents) {
    eventData = subset(tournamentData, TournamentName == event)
    playerNumber = nrow(eventData)
    nRounds = case_when(
      playerNumber >= 410 ~ 10,
      playerNumber >= 227 ~ 9,
      playerNumber >= 129 ~ 8,
      playerNumber >= 65 ~ 7,
      playerNumber >= 33 ~ 6,
      playerNumber >= 17 ~ 5,
      .default = 4
    )
    nRoundsEvent = rep(nRounds, nrow(eventData))
    nRoundsVec = c(nRoundsVec, nRoundsEvent)
  }
  tournamentData$NRounds = nRoundsVec
  
  #Add top8 points: 3*3 to 1st, 3*2 to 2nd, 3*1 to 3rd and 4th, none to others
  
  ConditionTop1 = tournamentData$NumericResult == 1
  ConditionTop2 = tournamentData$NumericResult == 2
  ConditionTop4 = tournamentData$NumericResult == 3 | 
    tournamentData$NumericResult == 4
  
  tournamentData$T8Points = ifelse(ConditionTop1,9,
                                   ifelse(ConditionTop2,6,
                                          ifelse(ConditionTop4,3,0)))
  
  #Add top8 defeats
  tournamentData$T8Defeats = rep(0, nrow(tournamentData))
  
  #Add the number of matches played in top8: 3 in final, 2 in semi final, 1 in
  # quarterfinal
  if (length(listEvents) >= 1) {
    conditionTop8Not1 = tournamentData$NumericResult >= 2 &
      tournamentData$NumericResult <= 8
    #0 for the winner and players who didn't reach top8
    # 1 for the others who reach top8
    tournamentData$T8Defeats = ifelse(conditionTop8Not1,
                                      tournamentData$T8Defeats+1,
                                      tournamentData$T8Defeats)
    
    ConditionTop2 = tournamentData$NumericResult <= 2
    ConditionTop4 = tournamentData$NumericResult == 3 | 
      tournamentData$NumericResult ==4
    ConditionTop8 = tournamentData$NumericResult <= 8 & 
      tournamentData$NumericResult >=4
    tournamentData$T8Matches = ifelse(ConditionTop2,3,
                                      ifelse(ConditionTop4,2,
                                             ifelse(ConditionTop8,1,0)))
  }
  
  return(tournamentData)
}

#' Import and clean tournament data
#'
#' @param eventType the category of events to keep in the data. It can be:
#' Event type:
#' All sources = Everything (except MTGO Leagues - for any filter)
#' All Events Top32 = Only events with a top32 (aka not MTGO Preliminaries)
#' Full Meta Events = Only events with the full metagame available (not MTGO Official results)
#' ManaTraders = ManaTraders Series results
#' Paper Events Full Meta = Full esults from MTG Melee
#' Paper Events Top32 = Results of the top32 from MTG Melee
#' MTGO Official Competitions = Results from the MTGO website
#' MTGO Events Top32 = MTGO results with a top32 (so not Preliminaries)
#' MTGO Preliminaries = As per name
#' @param mtgFormat the format of the tournaments to keep
#' @param tournamentDataPath the path of the JSON file to import
#' @param beginning the earliest date to keep in the dataset
#' @param end the latest date to keep in the dataset
#'
#' @return a dataframe with the structure and elements you need for metagame 
#' analysis
#' 
#' @export
#'
#' @examples
generate_df = function(rawData, eventType, mtgFormat, tournamentDataPath, 
                       beginning, end) {
  
  # # For development only
  # rawData = fromJSON(TournamentResultFile)[[1]]
  # eventType = EventType
  # mtgFormat = MtgFormat
  # tournamentDataPath = TournamentResultFile
  # beginning = Beginning
  # end = End

  # if (!mtgFormat == "All_Formats") {
  #   # probably filtered before with right use of the parser and import of a
  #   # correctly named file
  #   # We might lose tournaments such as Grand Open Qualifiers otherwise,
  #   # especially with the automation of MTG Melee
  #   rawData = rawData[grep(pattern = mtgFormat, x = rawData$Tournament), ]
  # }
  rawData$Date = as.Date(rawData$Date)
  
  #Select data for a specific period
  periodData = subset(rawData, Date >= as.Date(beginning) &
                        Date < as.Date(end))
  periodData$Points = as.numeric(periodData$Points)
  
  # Names and date don't allow the identification of an event on  their own, but
  # the combination of both can, hence the addition of another column for this
  # identification, with a more readable name than the file name column
  periodData$TournamentName = rep(NA, nrow(periodData))
  periodData$TournamentName = paste(periodData$Tournament,
                                    as.character(periodData$Date), sep =
                                      " ")
  periodData$Result[is.na(periodData$Result)] = 0
  
  # Remove decks without associated results
  periodData = periodData[!periodData$Result=="",]
  
  # Make the final position easier to manipulate as a number 
  # (doesn't work for Prelims)
  periodData$NumericResult = parse_number(periodData$Result)
  
  # Turn results into numeric values
  periodData$Wins = as.numeric(periodData$Wins)
  periodData$Losses = as.numeric(periodData$Losses)
  periodData$Draws = as.numeric(periodData$Draws)
  
  # /!\ Some events only have a top32, or don't even have one (Preliminary)
  if (eventType == EventTypes[1]) {
    # "1" = "All sources (except from Leagues and Team events)"
    # Remove the noise from leagues in case it wasn't done by the parser
    periodData = periodData[!grepl("League", periodData$Tournament),]
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    
    Top32Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    PrelimData = periodData[grep("Preliminary", periodData$Tournament),]
    resultDf = rbind(generate_Tournament_Data(Top32Data),
               generate_Prelim_Data(PrelimData))
    
  } else if (eventType == EventTypes[2]) {
    # "2" = "Paper, MTGO and Manatraders events Top32"
    # Remove the noise from leagues in case it wasn't done by the parser
    periodData = periodData[!grepl("League", periodData$Tournament),]
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    
    Top32Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    # Keep only the top32
    Top32Data = Top32Data[Top32Data$NumericResult <= 32, ]
    resultDf = generate_Tournament_Data(Top32Data)
    # Keep only the top32 of all those events
    
  } else if (eventType == EventTypes[3]) {
    # "3" = "Paper, MTGO and Manatraders events Top8"
    # Remove the noise from leagues in case it wasn't done by the parser
    periodData = periodData[!grepl("League", periodData$Tournament),]
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    
    Top8Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    # Keep only the top8
    Top8Data = Top8Data[Top8Data$NumericResult <= 8, ]
    resultDf = generate_Tournament_Data(Top8Data)
    
  } else if (eventType == EventTypes[4]) {
    # "4" = "Paper, MTGO and Manatraders events Top1"
    # Remove the noise from leagues in case it wasn't done by the parser
    periodData = periodData[!grepl("League", periodData$Tournament),]
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    
    Top1Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    # Keep only the top1
    Top1Data = Top1Data[Top1Data$NumericResult == 1, ]
    resultDf = generate_Tournament_Data(Top1Data)
    
  } else if (eventType == EventTypes[5]) {
    # "5" = "Paper, MTGO and Manatraders events X-2 or better"
    # Remove the noise from leagues in case it wasn't done by the parser
    periodData = periodData[!grepl("League", periodData$Tournament),]
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    
    X2Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    # Keep only the X-2 and better
    X2Data = X2Data[X2Data$Losses <= 2, ]
    resultDf = generate_Tournament_Data(X2Data)
    
  } else if (eventType == EventTypes[6]) {
    # "6" = "Paper, MTGO and Manatraders events X-1 or better"
    # Remove the noise from leagues in case it wasn't done by the parser
    periodData = periodData[!grepl("League", periodData$Tournament),]
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    
    X1Data = periodData[!grepl("Preliminary", periodData$Tournament),]
    # Keep only the X-1 and better
    X1Data = X1Data[X1Data$Losses <= 1, ]
    resultDf = generate_Tournament_Data(X1Data)
    
  } else if (eventType == EventTypes[7]) {
    # "7" = "Full Meta Events"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from Manatraders and MTG Melee, not the partial MTGO website
    MTData = periodData[grep(Manatraders_URL,
                             periodData$AnchorUri),]
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    resultDf = rbind(generate_Tournament_Data(MTData),
               generate_Tournament_Data(PaperData))
    
  } else if (eventType == EventTypes[8]) {
    #"8" = "ManaTraders"
    # Use data from Manatraders
    MTData = periodData[grep(Manatraders_URL,
                             periodData$AnchorUri),]
    resultDf = generate_Tournament_Data(MTData)
    
  } else if (eventType == EventTypes[9]) {
    # "9" = "Paper Events Full Meta"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    resultDf = generate_Tournament_Data(PaperData)
    
  } else if (eventType == EventTypes[10]) {
    # "10" = "Paper Events Top32"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top32
    PaperData = PaperData[PaperData$NumericResult <= 32, ]
    resultDf = generate_Tournament_Data(PaperData)
    
  } else if (eventType == EventTypes[11]) {
    # "11" = "Paper Events Top8"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top8
    PaperData = PaperData[PaperData$NumericResult <= 8, ]
    resultDf = generate_Tournament_Data(PaperData)
    
  } else if (eventType == EventTypes[12]) {
    # "12" = "Paper Events Top1"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top1
    PaperData = PaperData[PaperData$NumericResult <= 1, ]
    resultDf = generate_Tournament_Data(PaperData)
    
  } else if (eventType == EventTypes[13]) {
    # "13" = "Paper Events X-2 or better"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top1
    PaperData = PaperData[PaperData$Losses <= 2, ]
    resultDf = generate_Tournament_Data(PaperData)
    
  } else if (eventType == EventTypes[14]) {
    # "14" = "Paper Events X-1 or better"
    # Remove the Team Trio events providing unusable data
    periodData = periodData[!grepl("Team", periodData$Tournament),]
    # Use data from MTG Melee
    PaperData = periodData[grep(MTGMelee_URL,
                                periodData$AnchorUri),]
    # Keep only the top1
    PaperData = PaperData[PaperData$Losses <= 1, ]
    resultDf = generate_Tournament_Data(PaperData)
    
  } else{
    MTGOData = periodData[grep(MTGO_URL,
                               periodData$AnchorUri),]
    # Remove the noise from leagues in case it wasn't done by the parser
    MTGOData = MTGOData[!grepl("League", MTGOData$Tournament),]
    
    if (eventType == EventTypes[15]) {
      # "15" = "MTGO Official Competitions"
      MTGONonPrelimData = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      PrelimData = MTGOData[grep("Preliminary", MTGOData$Tournament),]
      resultDf = rbind(generate_Tournament_Data(MTGONonPrelimData),
                 generate_Prelim_Data(PrelimData))
      
    } else if (eventType == EventTypes[16]) {
      # "16" = "MTGO Official Competitions with top8"
      # MTGO tournaments with a top32, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGONonPrelimData = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      resultDf = generate_Tournament_Data(MTGONonPrelimData)
      
    } else if (eventType == EventTypes[17]) {
      # "17" = "MTGO Events Top8"
      # MTGO tournaments with a top32, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOTop8Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top8
      MTGOTop8Data = MTGOTop8Data[MTGOTop8Data$NumericResult <= 8, ]
      resultDf = generate_Tournament_Data(MTGOTop8Data)
      
    } else if (eventType == EventTypes[18]) {
      # "18" = "MTGO Events Top1"
      # MTGO tournaments with a top32, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOTop1Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top8
      MTGOTop1Data = MTGOTop1Data[MTGOTop1Data$NumericResult <= 1, ]
      resultDf = generate_Tournament_Data(MTGOTop1Data)
      
    } else if (eventType == EventTypes[19]) {
      # "19" = "MTGO Events X-2 or better"
      # MTGO tournaments with a top32, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOX2Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top8
      MTGOX2Data = MTGOX2Data[MTGOX2Data$Losses <= 2, ]
      resultDf = generate_Tournament_Data(MTGOX2Data)
      
    } else if (eventType == EventTypes[20]) {
      # "20" = "MTGO Events X-1 or better"
      # MTGO tournaments with a top32, so not Preliminaries (nor Leagues,
      # already filtered)
      MTGOX1Data = MTGOData[!grepl("Preliminary", MTGOData$Tournament),]
      # Keep only the top1
      MTGOX1Data = MTGOX1Data[MTGOX1Data$Losses <= 1, ]
      resultDf = generate_Tournament_Data(MTGOX1Data)
      
    } else if (eventType == EventTypes[21]) {
      # "21" = "MTGO Preliminaries"
      # Preliminaries only
      PrelimData = MTGOData[grep("Preliminary", MTGOData$Tournament),]
      resultDf = generate_Prelim_Data(PrelimData)
      
    } else if (eventType == EventTypes[22]) {
      # "22" = "MTGO Preliminaries and Full Meta Events"
      # Preliminaries and tournaments with the full results available
      # Remove the Team Trio events providing unusable data
      periodData = periodData[!grepl("Team", periodData$Tournament),]
      # Use data from Manatraders and MTG Melee, not the partial MTGO website
      MTData = periodData[grep(Manatraders_URL,
                               periodData$AnchorUri),]
      PaperData = periodData[grep(MTGMelee_URL,
                                  periodData$AnchorUri),]
      PrelimData = MTGOData[grep("Preliminary", MTGOData$Tournament),]
      resultDf = rbind(generate_Tournament_Data(MTData),
                       generate_Tournament_Data(PaperData),
                       generate_Prelim_Data(PrelimData))
      
    }
  }
  
  if(addColor){
    resultDf$Archetype$Archetype = 
      mapply(function(archetypeName, archetypeColor) {
        ifelse(archetypeName %in% c("Hammer Time", "Murktide", "Creativity",
                                    "Prowess", "Footfalls", "Burn", 
                                    "Living End", "Merfolk", "Grinding Breach",
                                    "Mill","Hardened Scales","Asmo Food",
                                    "Goryo Reanimator", "Breach Value", 
                                    "Affinity"),
               paste(archetypeColor, archetypeName),
               archetypeName
        )
      }, resultDf$Archetype$Archetype, resultDf$Archetype$Color)
  }
  
  # resultDf$Allboards = mapply(function(Mainboard, Sideboard){
  #   list(as.data.frame(rbindlist(list(Mainboard, Sideboard))[, lapply(.SD, sum, na.rm =T), by = CardName]))
  # }, resultDf$Mainboard, resultDf$Sideboard)
  
  return(resultDf)
}

#' Get conflicted archetype URL
#'
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of URL of archetypes with Conflicts
#' @export
#'
#' @examples
getConflictURL = function(df){
  return(df[startsWith(df$Archetype$Archetype,"Conflict")==TRUE,]$AnchorUri)
}

#' Get conflicted archetype names
#'
#' @param df the dataframe returned bygenerate_df()
#'
#' @return the list of names of archetypes with Conflicts
#' @export
#'
#' @examples
getConflictArchetype = function(df){
  return(df[startsWith(df$Archetype$Archetype,
                       "Conflict")==TRUE,]$Archetype$Archetype)
}

#' Get Unknown archetype URL
#'
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of URL of archetypes classified as Unknown
#' @export
#'
#' @examples
getUnknown = function(df){
  return(df[df$Archetype$Archetype=="Unknown",]$AnchorUri)
}

#' Get all URL of decks with a given card
#'
#' @param cardName a string with the name of the card to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of decks with a specific card in the data. 
#' Empty if nothing fits (wrong name or not in the data).
#' @export
#'
#' @examples
getURLofCard = function(cardName,df){
  archetypeURL = c()
  for (i in 1:nrow(df)){
    if (length(grep(cardName,df$Mainboard[[i]]$CardName)) + 
        length(grep(cardName,df$Sideboard[[i]]$CardName))>0){
      archetypeURL = c(archetypeURL,df$AnchorUri[[i]])
    }
  }
  return(archetypeURL)
}

#' Get all URL of decks of a given archetype
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the list URL of decks of a given archetype, provided in parameters.
#' Empty if nothing fits (wrong name or not in the data).
#' @export
#'
#' @examples
getURLofDeck = function(deckName,df){
  return(df[df$Archetype$Archetype==deckName,]$AnchorUri)
}

#' Get the URL of the deck with the best win/loss ratio for a given archetype
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the URL of the most successful deck of a given archetype.
#' The most successful is defined as having the highest difference between its
#' wins and defeats. A 7-0 is equivalent to a 10-3. Idea by Frank Karsten.
#' Empty if nothing fits (wrong name or not in the data).
#' @export
#'
#' @examples
getBestDeck = function(deckName,df){
  df2=df[df$Archetype$Archetype==deckName,]
  df2$WinLossScore = df2$Wins + df2$T8Points/3 -
    df2$Losses - df2$T8Defeats
  if(nrow(df2)>0){
    df2=df2[df2$WinLossScore==max(df2$WinLossScore),]
  }
  return(df2$AnchorUri)
}

#' Get the decklist of the deck with the best win/loss ratio for a given archetype
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the URL of the most successful deck of a given archetype.
#' The most successful is defined as having the highest difference between its
#' wins and defeats. A 7-0 is equivalent to a 10-3. Idea by Frank Karsten.
#' Empty if nothing fits (wrong name or not in the data).
#' @export
#'
#' @examples
getBestDeckList = function(deckName,df){
  df2=df[df$Archetype$Archetype==deckName,]
  df2$WinLossScore = df2$Wins + df2$T8Points/3 -
    df2$Losses - df2$T8Defeats
  if(nrow(df2)>0){
    df2=df2[df2$WinLossScore==max(df2$WinLossScore),]
  }
  return(list(df2$Mainboard, df2$Sideboard))
}

#' Matchup data between two given archetypes
#'
#' @param df the dataframe returned by generate_df()
#' @param arch1 a string with the name of the archetype compared to the other
#' @param arch2 a string with the name of the archetype as opponent of the arch1
#'
#' @return a vector with the number of wins and losses in that matchup.
#' @export
#'
#' @examples
get_matchup_data = function(df,arch1,arch2){
  winsArch1VS2 = 0
  lossesArch1VS2 = 0
  dfArch1 = df[df$Archetype$Archetype==arch1,]
  conditionMUNotNull = !sapply(dfArch1$Matchups, function(x) length(x) == 0 )
  for (i in (1:nrow(dfArch1))[conditionMUNotNull]){
    matchesI = dfArch1[i,]$Matchups[[1]]
    matchesArch1VS2 = matchesI[matchesI$OpponentArchetype == arch2,]
    
    WinsI = matchesArch1VS2$Wins 
    DefeatsI = matchesArch1VS2$Losses 
    
    winsArch1VS2 = winsArch1VS2 + sum(WinsI > DefeatsI)
    lossesArch1VS2 = lossesArch1VS2 + sum(WinsI < DefeatsI) 
  }
  
  return(c(Wins = winsArch1VS2, Losses = lossesArch1VS2))
}

#' #' Matchup data between two given archetypes
#' #'
#' #' @param df the dataframe returned by generate_df()
#' #'
#' #' @return the dataframe using only the constructed rounds for the PT.
#' #' Top8 matches are included in the rounds data.
#' #'
#' #' @export
#' #'
#' #' @examples
#' updateDfForPT = function(df){
#'   
#'   conditionPT = !grepl("Pro Tour", df$Tournament)
#'   
#'   df[conditionPT,]$Matchups = mapply(function(Matchups){
#'     list(Matchups[-c(1,2,3,9,10,11),])
#'   },df[conditionPT,]$Matchups)
#' 
#'   df[conditionPT,]$Wins = mapply(function(Matchups){
#'     sum(Matchups$Wins > Matchups$Losses)
#'   },df[conditionPT,]$Matchups)
#' 
#'   df[conditionPT,]$Losses = mapply(function(Matchups){
#'     sum(Matchups$Wins < Matchups$Losses)
#'   },df[conditionPT,]$Matchups)
#' 
#'   df[conditionPT,]$Draws = mapply(function(Matchups){
#'     sum(Matchups$Wins == Matchups$Losses)
#'   },df[conditionPT,]$Matchups)
#' 
#'   df[conditionPT,]$T8Defeats = rep(NA,nrow(df[conditionPT,]))
#'   df[conditionPT,]$T8Matches = rep(NA,nrow(df[conditionPT,]))
#'   df[conditionPT,]$T8Points = rep(NA,nrow(df[conditionPT,]))
#' 
#'   df
#' }
