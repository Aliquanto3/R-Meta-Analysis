################################################################################
#####                  MTG Tournament Result Analysis                      #####
#####                           by AnaÃ«l Yahi                              #####
#####               based on data generated by Phelps-san                  #####
#####            https://github.com/Badaro/MTGOArchetypeParser             #####
################################################################################
#####                        04-Decklist_Analysis.R                        #####
##### Use this file to import functions that analyse decklists of a given  #####
##### archetype to provide the best and average ones.                      #####
################################################################################

# For development
# df = tournamentDf
# deckName = "Creativity"

#' Round to the nearest number
#'
#' @param x the number to round
#' @param digits the number of digits to be rounded to
#'
#' @return the nearest number to x with digits numbers after the comma
#' @export
#'
#' @examples
round2 = function(x, digits) {
  posneg = sign(x)
  z = abs(x)*10^digits
  z = z + 0.5 + sqrt(.Machine$double.eps)
  z = trunc(z)
  z = z/10^digits
  z*posneg
}

#' Get all the unique cards played in a given archetype
#'
#' @param deckName a string with the name of the archetype to find
#' @param color a string with the color of the archetype to keep. Ex: "WUBRG"
#' @param df the dataframe returned by generate_df()
#'
#' @return the list of cards played in the archetype in a dataframe, with data
#' on their presence and win rate, split between MD and SB
#' @export
#'
#' @examples
get_archetype_card_data = function(deckName, color, df){
  
  # Filter to keep the data of a given archetype in a chosen color
  archetypeDf = df[df$Archetype$Archetype == deckName,]
  archetypeDf = archetypeDf[archetypeDf$Archetype$Color == color,]
  
  # Get the card list of each deck: card name and the corresponding number of 
  # copies, both for mainboard (MD = maindeck) and sideboard (SB)
  cardNamesMD = unlist(lapply(archetypeDf$Mainboard, 
                              function(archetypeBoardVector) 
                                {archetypeBoardVector$CardName}))
  cardCountsMD = unlist(lapply(archetypeDf$Mainboard,  
                               function(archetypeBoardVector) 
                               {archetypeBoardVector$Count}))
  winCountsMD = unlist(mapply(function(MDCards, numberWins)
    {rep(numberWins,length(MDCards$CardName))}, 
                              archetypeDf$Mainboard, archetypeDf$NWins))
  lossCountsMD = unlist(mapply(function(MDCards, numberLosses)
  {rep(numberLosses,length(MDCards$CardName))}, 
  archetypeDf$Mainboard, archetypeDf$NDefeats))
  
  cardNamesSB = unlist(lapply(archetypeDf$Sideboard, 
                              function(archetypeBoardVector) 
                              {archetypeBoardVector$CardName}))
  cardCountsSB = unlist(lapply(archetypeDf$Sideboard,  
                               function(archetypeBoardVector) 
                               {archetypeBoardVector$Count}))
  winCountsSB = unlist(mapply(function(SBCards, numberWins)
  {rep(numberWins,length(SBCards$CardName))}, 
  archetypeDf$Sideboard, archetypeDf$NWins))
  lossCountsSB = unlist(mapply(function(SBCards, numberLosses)
  {rep(numberLosses,length(SBCards$CardName))}, 
  archetypeDf$Sideboard, archetypeDf$NDefeats))
  
  # Regroup the data in dataframes
  MDCards = data.frame(Card.Name = cardNamesMD, 
                       Copies.In.MD = cardCountsMD,
                       Wins.In.MD = winCountsMD,
                       Losses.In.MD = lossCountsMD)
  SBCards = data.frame(Card.Name = cardNamesSB, 
                       Copies.In.SB = cardCountsSB,
                       Wins.In.SB = winCountsSB,
                       Losses.In.SB = lossCountsSB)
  
  # Keep only one row by different card, summing their copies, wins and defeats
  MDCardsAggregate = aggregate(. ~ Card.Name, data = MDCards, sum)
  SBCardsAggregate = aggregate(. ~ Card.Name, data = SBCards, sum)
  
  # Create a dataframe listing all the different cards in the archetype, 
  # including the number of copies that are ran of each
  archetypeCardData = 
    merge(MDCardsAggregate, SBCardsAggregate, by = "Card.Name", all = TRUE)
  archetypeCardData[is.na(archetypeCardData)] = 0
  archetypeCardData$Copies.In.Decks = archetypeCardData$Copies.In.MD +
    archetypeCardData$Copies.In.SB
  archetypeCardData$Wins.In.Decks = 
    archetypeCardData$Wins.In.MD + 
    archetypeCardData$Wins.In.SB
  archetypeCardData$Losses.In.Decks = 
    archetypeCardData$Losses.In.MD + 
    archetypeCardData$Losses.In.SB

  archetypeCardData$WR.In.MD = 
    round(archetypeCardData$Wins.In.MD /
            (archetypeCardData$Wins.In.MD + 
               archetypeCardData$Losses.In.MD) * 100, digits = 2)
  archetypeCardData$Lower.95.CI.WR.In.MD = 
    mapply(function(NWins,NLosses)
    {ifelse(NLosses>0,round(binom.test(NWins, NWins + NLosses, 
                      p=0.5,alternative = "two.sided", 
                      conf.level=0.95)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.MD,
    archetypeCardData$Losses.In.MD)
  archetypeCardData$Upper.95.CI.WR.In.MD =  
    mapply(function(NWins,NLosses)
    {ifelse(NLosses>0,round(binom.test(NWins, NWins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=0.95)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.MD,
    archetypeCardData$Losses.In.MD)
  
  archetypeCardData$WR.In.SB = 
    round(archetypeCardData$Wins.In.SB /
            (archetypeCardData$Wins.In.SB + 
               archetypeCardData$Losses.In.SB) * 100, digits = 2)
  archetypeCardData$Lower.95.CI.WR.In.SB = 
    mapply(function(NWins,NLosses)
    {ifelse(NLosses>0,round(binom.test(NWins, NWins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=0.95)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.SB,
    archetypeCardData$Losses.In.SB)
  archetypeCardData$Upper.95.CI.WR.In.SB =  
    mapply(function(NWins,NLosses)
    {ifelse(NLosses>0,round(binom.test(NWins, NWins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=0.95)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.SB,
    archetypeCardData$Losses.In.SB)
  
  archetypeCardData$WR.In.Decks = 
    round(archetypeCardData$Wins.In.Decks /
            (archetypeCardData$Wins.In.Decks + 
               archetypeCardData$Losses.In.Decks) * 100, digits = 2)
  archetypeCardData$Lower.95.CI.WR.In.Decks = 
    mapply(function(NWins,NLosses)
    {ifelse(NLosses>0,round(binom.test(NWins, NWins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=0.95)$conf.int[1] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.Decks,
    archetypeCardData$Losses.In.Decks)
  archetypeCardData$Upper.95.CI.WR.In.Decks =  
    mapply(function(NWins,NLosses)
    {ifelse(NLosses>0,round(binom.test(NWins, NWins + NLosses, 
                      p=0.5,alternative="two.sided", 
                      conf.level=0.95)$conf.int[2] * 100, digits = 2),0)},
    archetypeCardData$Wins.In.Decks,
    archetypeCardData$Losses.In.Decks)

  archetypeCardData$Number.Of.MD = 
    sapply(archetypeCardData$Card.Name, 
           function(currentCard) 
           {nrow(MDCards[MDCards$Card.Name == currentCard,])})
  archetypeCardData$Number.Of.SB  = 
    sapply(archetypeCardData$Card.Name, 
           function(currentCard) 
           {nrow(SBCards[SBCards$Card.Name == currentCard,])})
  
  archetypeCardData$Share.Of.MD = 
    round(archetypeCardData$Number.Of.MD / nrow(archetypeDf) * 100, 
          digits = 2)
  archetypeCardData$Share.Of.SB  = 
    round(archetypeCardData$Number.Of.SB / nrow(archetypeDf) * 100, 
          digits = 2)
  
  
  archetypeCardData$Average.MD.Count.If.Present =
    round(sapply(archetypeCardData$Card.Name,
           function(currentCard) 
             {mean(MDCards[MDCards$Card.Name == currentCard,]$Copies.In.MD)}), 
          digits = 2)
  archetypeCardData$Average.SB.Count.If.Present =
    round(sapply(archetypeCardData$Card.Name,
           function(currentCard)
           {mean(SBCards[SBCards$Card.Name == currentCard,]$Copies.In.SB)}), 
          digits = 2)
  
  archetypeCardData$Most.Common.MD.Count = 
    lapply(archetypeCardData$Card.Name, function(cardName) 
        {mostPresentCountsMD = as.numeric(names(which.max(
          table(MDCards[MDCards$Card.Name == cardName,]$Copies.In.MD))));
      ifelse(length(mostPresentCountsMD)>0, min(mostPresentCountsMD),0)})
    
  archetypeCardData$Most.Common.SB.Count = 
    lapply(archetypeCardData$Card.Name, function(cardName) 
    {mostPresentCountsSB = as.numeric(names(which.max(
      table(SBCards[SBCards$Card.Name == cardName,]$Copies.In.SB))));
    ifelse(length(mostPresentCountsSB)>0,min(mostPresentCountsSB),0)})
  
  archetypeCardData[is.na(archetypeCardData)] = 0
  
  
  return(archetypeCardData)
}

#' Get the most played color combination for a given deck
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return the most played color combination for a given archetype as a string
#' @export
#'
#' @examples
get_archetype_most_common_colors = function(deckName, df){
  return(names(which.max(
    table(df[df$Archetype$Archetype == deckName,]$Archetype$Color))))
}

#' Get all the color combinations for a given deck
#'
#' @param deckName a string with the name of the archetype to find
#' @param df the dataframe returned by generate_df()
#'
#' @return all the color combinations for a given archetype as a vectof
#' @export
#'
#' @examples
get_archetype_colors = function(deckName, df){
  return(table(df[df$Archetype$Archetype == deckName,]$Archetype$Color))
}

# # For development
# deckName = "Creativity"
# get_archetype_colors(deckName, df)
# archetypeMainColor = get_archetype_most_common_colors(deckName, df)
# color = "UBRG" 

#' Get the average decklist for an archetype in a specific color combination
#'
#' @param deckName a string with the name of the archetype to find
#' @param color a string with the color of the archetype to keep. Ex: "WUBRG"
#' @param df the dataframe returned by generate_df()
#'
#' @return a dataframe with the card names and their count in the 
#' @export
#'
#' @examples
get_average_decklist = function(deckName, color, df){
  
  # Filter to keep the data of a given archetype in a chosen color
  archetypeDf = df[df$Archetype$Archetype == deckName,]
  archetypeDf = archetypeDf[archetypeDf$Archetype$Color == color,]
  
  # Filter to keep the data of a given archetype
  archetypeCardData = 
    get_archetype_card_data(deckName, color, df)
  
  # Minimum value of the most present number of cards in MD
  averageCardTotalMD = min(as.numeric(names(which.max(table(unlist(
    lapply(archetypeDf$Mainboard, function(archetypeBoardVector) 
      {sum(archetypeBoardVector$Count)})))))))
  
  averageMaindeck = data.frame(CardNamesMD = character(),
                               CardCountMD = numeric(),
                               AverageCountMD = numeric(),
                               ShareMD = numeric())
  
  while(sum(averageMaindeck$CardCountMD) < averageCardTotalMD){
    mostPresentShare = max(archetypeCardData$Share.Of.MD)
    mostPresentCards = 
      archetypeCardData[archetypeCardData$Share.Of.MD == 
                          mostPresentShare,]
    archetypeCardData = archetypeCardData[
        archetypeCardData$Share.Of.MD != mostPresentShare,]
    
    while(nrow(mostPresentCards)>0 && 
          sum(averageMaindeck$CardCountMD) < averageCardTotalMD){
      averageMaindeck[nrow(averageMaindeck) + 1,] = 
        c(mostPresentCards[1,]$Card.Name, 
          mostPresentCards[1,]$Most.Common.MD.Count, 
          mostPresentCards[1,]$Average.MD.Count.If.Present,
          mostPresentCards[1,]$Share.Of.MD)
      mostPresentCards = mostPresentCards[-1,]
      averageMaindeck$CardCountMD =  round2(
        as.numeric(averageMaindeck$CardCountMD),0)
    }
    while(sum(averageMaindeck$CardCountMD) > averageCardTotalMD){
      if(averageMaindeck[nrow(averageMaindeck),]$CardCountMD > 
         sum(averageMaindeck$CardCountMD) - averageCardTotalMD){
        averageMaindeck[nrow(averageMaindeck),]$CardCountMD = 
          averageMaindeck[nrow(averageMaindeck),]$CardCountMD - 
          (sum(averageMaindeck$CardCountMD) - averageCardTotalMD)
      }else{
        averageMaindeck = head(averageMaindeck, - 1)   
      }
    }
  }
  # # For development
  # sum(averageMaindeck$CardCountMD)
  
  averageCardTotalSB = 15
  
  averageSideboard = data.frame(CardNamesSB = character(),
                               CardCountSB = numeric(),
                               AverageCountSB = numeric(),
                               ShareSB = numeric())
  
  while(sum(averageSideboard$CardCountSB) < averageCardTotalSB){
    mostPresentShare = max(archetypeCardData$Share.Of.SB)
    mostPresentCards = 
      archetypeCardData[archetypeCardData$Share.Of.SB == 
                          mostPresentShare,]
    archetypeCardData = archetypeCardData[
      archetypeCardData$Share.Of.SB != mostPresentShare,]
    
    while(nrow(mostPresentCards)>0 && 
          sum(averageSideboard$CardCountSB) < averageCardTotalSB){
      averageSideboard[nrow(averageSideboard) + 1,] = 
        c(mostPresentCards[1,]$Card.Name, 
          mostPresentCards[1,]$Most.Common.SB.Count, 
          mostPresentCards[1,]$Average.SB.Count.If.Present,
          mostPresentCards[1,]$Share.Of.SB)
      mostPresentCards = mostPresentCards[-1,]
      averageSideboard$CardCountSB =  round2(
        as.numeric(averageSideboard$CardCountSB),0)
    }
    while(sum(averageSideboard$CardCountSB) > averageCardTotalSB){
      if(averageSideboard[nrow(averageSideboard),]$CardCountSB > 
         sum(averageSideboard$CardCountSB) - averageCardTotalSB){
        averageSideboard[nrow(averageSideboard),]$CardCountSB = 
          averageSideboard[nrow(averageSideboard),]$CardCountSB - 
          (sum(averageSideboard$CardCountSB) - averageCardTotalSB)
      }else{
        averageSideboard = head(averageSideboard, - 1)   
      }
    }
  }
  
  return(averageMaindeck)
}


