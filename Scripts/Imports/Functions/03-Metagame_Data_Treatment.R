################################################################################
#####                  MTG Tournament Result Analysis                      #####
#####                           by Anaël Yahi                              #####
#####               based on data generated by Phelps-san                  #####
#####            https://github.com/Badaro/MTGOArchetypeParser             #####
################################################################################
#####                      03-Metagame_Data_Treatment.R                    #####
##### Use this file to import functions that will provide the classical    #####
##### metagame analysis metrics.                                           #####
################################################################################

library(dplyr) 
library(tidyverse)

# # For development
# df = tournamentDf
# chartShare = ChartShare
# presence = "Matches"
# beginning = Beginning
# end = End
# eventType = EventType
# mtgFormat = MtgFormat
# statShare = StatShare
# archetype = "Omnath Scapeshift"

#' Add a weight to the match results based on elapsed time.
#' Multiply wins, losses and draws based on the number of weeks since the
#' oldest week in the data.
#' Cannot divide (unless you round the results), because you need an integer
#' for the computation of the confidence interval.
#'
#' @param df the dataframe generated by generate_df()
#'
#' @return the same dataframe with updated wins, losses and draws based on the
#' number of elapsed weeks
#' @export
#'
#' @examples
addTimeWeight = function(df){
  
  df$Wins = df$Wins * (df$Week - min(df$Week) + 1)
  df$Losses = df$Losses * (df$Week - min(df$Week) + 1)
  df$Draws = df$Draws *(df$Week - min(df$Week) + 1)
  
  df
}

#' List of all the different archetypes in the data
#'
#' @param df the dataframe generated by generate_df()
#'
#' @return a 1-column dataframe with the list of archetypes in the dataset
#' @export
#'
#' @examples
generate_archetype_list = function(df){
  archetype_list=data.frame(unique(df$Archetype$Archetype))
  names(archetype_list)[1] = c("Archetype")
  return(archetype_list)
}

#' Get the presence of a given archetype
#'
#' @param df the dataframe generated by generate_df() 
#' @param archetypeName a string, the name of the archetype you are looking for
#' @param presence the definition of metagame presence (aka share) to use. 
#' It can be:
#' - "Copies": the number of lines in the dataframe dedicated to that archetype
#' - "Players": the number of different players piloting that archetype
#' - "Matches": the number of matches played by the archetype
#'
#' @return an integer, the value of the presence by the chosen metric
#' @export
#'
#' @examples
get_archetype_presence = function(df,archetypeName,presence){
  df2=df[df$Archetype$Archetype==archetypeName,]
  
  return(ifelse(presence=="Copies",nrow(df2),
                                 ifelse(presence=="Players",
                                        length(unique(df2$Player)),
                                        ifelse(presence=="Matches",
                                               sum(df2$Matches),
                                               NA))))
}

#' Get the metagame presence (aka share) of each archetype
#'
#' @param df the dataframe generated by generate_df() 
#' @param statShare the value of the cut to be set in "Others" for an archetype.
#' It must be a numeric value. For a cut at 2%, use statShare=2 (not 0.02).
#' @param presence the definition of metagame presence (aka share) to use. 
#' It can be:
#' - "Copies": the number of lines in the dataframe dedicated to that archetype
#' - "Players": the number of different players piloting that archetype
#' - "Matches": the number of matches played by the archetype
#'
#' @return
#' @export
#'
#' @examples
generate_metagame_data = function(df,statShare,presence){
  
  # df = tournamentDf
  # statShare = ChartShare
  # presence = Presence
  
  archetype_list=generate_archetype_list(df)
  
  #Add the presence of each archetype in the data
  archetype_list$Presence = 
    sapply(X = archetype_list$Archetype, 
           FUN = get_archetype_presence, 
           df = df, presence = presence)
  
  # Aggregate all the archetypes accounting for less than statShare % of the 
  # presence in the dataset
  graph_treshold = statShare/100*sum(archetype_list$Presence)
  main_archetype_list = arrange(archetype_list[
    archetype_list$Presence >= graph_treshold, ],desc(Presence))
  
  # Add an "Other" category aggregating the presence of archetypes under 
  # statShare %
  presence_other = sum(archetype_list[archetype_list$Presence < 
                                        graph_treshold, ]$Presence)
  if(presence_other>0){
    otherName = paste("Other (each <",statShare,"%)",sep="")
    main_archetype_list = rbind(main_archetype_list, 
                                data.frame(Archetype = otherName, 
                                           Presence = presence_other))
  }
  
  # Add the metagame share as % in the dataframe
  main_archetype_list$Share = 
    as.numeric(format(round(
      main_archetype_list$Presence/sum(main_archetype_list$Presence)*100,
                                              1), nsmall = 1))
  
  # Force an order for the archetypes, with Other as the last one
  # (useful for ggplot)
  main_archetype_list$Archetype = reorder(main_archetype_list$Archetype, 
                                    as.numeric(main_archetype_list$Presence))
  if(presence_other>0){
    main_archetype_list$Archetype = 
      relevel(main_archetype_list$Archetype, otherName)
  }
  main_archetype_list$Archetype=fct_rev(main_archetype_list$Archetype)
  
  return(main_archetype_list)
}

#' Table of the presence and win rate by archetype
#'
#' @param df the dataframe generated by generate_df()
#' @param presence the definition of metagame presence (aka share) to use. 
#' It can be:
#' - "Copies": the number of lines in the dataframe dedicated to that archetype
#' - "Players": the number of different players piloting that archetype
#' - "Matches": the number of matches played by the archetype  
#'
#' @return a dataframe with the metrics to analyze the archetypes.
#' 1 column for the archetypes
#' - Archetype
#' 3 columns for the match results
#' - Wins
#' - Losses
#' - Draws
#' 4 columns for the presence
#' - Copies
#' - Players
#' - Matches
#' - Presence (the chosen one as parameter)
#' 3 columns for the win rate
#' - Measured.Win.Rate
#' - Lower.Bound.of.CI.on.WR
#' - Upper.Bound.of.CI.on.WR
#' @export
#'
#' @examples
archetype_metrics = function(df, presence){
  
  # #For development only
  # df = tournamentDf
  # presence = Presence
  
  #GET THE LIST OF THE DIFFERENT ARCHETYPES IN THE DATA
  metric_df = generate_archetype_list(df)
  
  # Add the data required to computes win rates
  metric_df$Wins = sapply(X = metric_df$Archetype, 
                           FUN = function(archetype, df) {
                             sum(df[df$Archetype$Archetype == 
                                      archetype,]$Wins)
                           }, df)
  metric_df$Defeats = sapply(X = metric_df$Archetype, 
                              FUN = function(archetype, df) {
                                sum(df[df$Archetype$Archetype == 
                                         archetype,]$Losses)
                              }, df)
  metric_df$Draws = sapply(X = metric_df$Archetype, 
                            FUN = function(archetype, df) {
                              sum(df[df$Archetype$Archetype == 
                                       archetype,]$Draws)
                            }, df)
  
  # Remove archetypes that appear in the JSON but don't have any recorded match
  metric_df = metric_df[metric_df$Wins + metric_df$Defeats >0,]
  
  # Add presence metrics
  metric_df$Copies = sapply(X = metric_df$Archetype, 
                            FUN = function(archetype, df) {
                              nrow(df[df$Archetype$Archetype == archetype,])
                            }, df)
  metric_df$Players = sapply(X = metric_df$Archetype, 
                             FUN = function(archetype, df) {
                               length(unique(df[df$Archetype$Archetype == 
                                                  archetype,]$Player))
                             }, df)
  metric_df$Matches = metric_df$Wins + metric_df$Draws + metric_df$Defeats
  
  # Compute the presence based on the one expected as parameter
  metric_df$Presence = unlist(100 * metric_df[presence]/sum(metric_df[presence]))
  
  # Compute the win rate and confidence interval on it
  metric_df$Measured.Win.Rate = metric_df$Wins * 100 / 
    (metric_df$Wins + metric_df$Defeats)
  
  metric_df$Lower.Bound.of.CI.on.WR = mapply(FUN = function(wins, defeats){
    binom.test(wins, wins + defeats, p = 0.5, alternative = "two.sided", 
               conf.level = CIPercent)$conf.int[1] * 100
  }, metric_df$Wins, metric_df$Defeats)
  
  metric_df$Upper.Bound.of.CI.on.WR =  mapply(FUN = function(wins, defeats){
    binom.test(wins, wins + defeats, p = 0.5, alternative = "two.sided", 
               conf.level = CIPercent)$conf.int[2] * 100
  }, metric_df$Wins, metric_df$Defeats)
  
  return(metric_df)
}

#' Get the presence value under which the least played archetypes are removed
#' for the tier list generation
#'
#' @param metric_df the dataframe generated by archetype_metrics()  
#' @param chartShare the défault required metagame share to appear on charts
#'
#' @return the metagame share under which the archetypes are cut
#' @export
#'
#' @examples
updateStatShare = function(metric_df,ChartShare){
  if(Share.autoupdate){
    StatShare =
      round(mean(unlist(metric_df$Presence)) / 
              sum(unlist(metric_df$Presence)) * 100, digits = 2)
    ChartShare = max(StatShare, 1)
  }else {
    StatShare = ChartShare
  }
  StatShare
}

#' Add the normalized sum data to the archetype metric dataframe
#'
#' @param metric_df the dataframe generated by archetype_metrics()  
#' @param statShare the metagame share under which the archetypes are cut
#'
#' @return a dataframe adding keeping only the most present decks (above average
#'  presence) and adding the following columns to the input: 
#'  - the normalized input presence 
#'  - the normalized win rate 
#'  - the sum of the normalized presence and win rate
#' @export
#'
#' @examples
archetype_normalized_sum = function(metric_df, statShare){
  
  # Make the values of both metrics start at 0 by subtracting the minimum value
  
  # Keep only the most present decks
  metric_df_start_at_0 = metric_df[metric_df$Presence > statShare,]
  
  # Use the logarithm of the presence
  # It usually has an exponential distribution, make it linear
  metric_df_start_at_0$Normalized.Presence = 
    unlist(log(metric_df_start_at_0$Presence) - 
             log(min(metric_df_start_at_0$Presence)))
  
  metric_df_start_at_0$Normalized.Win.Rate = 
    metric_df_start_at_0$Measured.Win.Rate -
    min(metric_df_start_at_0$Measured.Win.Rate)
  
  # Make the values of both metrics go up to 1 by dividing by the maximum value
  metric_df_between_0_and_1 = metric_df_start_at_0
  
  metric_df_between_0_and_1$Normalized.Presence = 
    metric_df_between_0_and_1$Normalized.Presence / 
    max(metric_df_between_0_and_1$Normalized.Presence)
  
  metric_df_between_0_and_1$Normalized.Win.Rate = 
    metric_df_between_0_and_1$Normalized.Win.Rate / 
    max(metric_df_between_0_and_1$Normalized.Win.Rate)
  
  # We now have normalized metrics we can sum
  metric_df_normalized=metric_df_between_0_and_1
  metric_df_normalized$Normalized.Sum.of.Presence.and.WR = 
    metric_df_normalized$Normalized.Presence + 
    metric_df_normalized$Normalized.Win.Rate
  
  return(metric_df_normalized)
}

#' Add the the tiers to the archetype dataframe with normalized sum data
#'
#' @param metric_df_normalized the dataframe generated by 
#' archetype_normalized_sum()  
#' @param tierNames the names of tier metrics
#'
#' @return a dataframe adding keeping only the most present decks (above average
#'  presence) and adding the following columns to the input: 
#'  - the rank based on the normalized sum of presence and win rate
#'  - the tier associated to the normalized sum
#'  - the rank based on the lower bound on the CI on the WR
#'  - the tier associated to the lower bound
#' @export
#'
#' @examples
archetype_tiers = function(metric_df_normalized, tierNames){
  
  # Order the rows based on the decreasing ranking according to that 
  # normalized sum
  metric_df_normalized = metric_df_normalized[order(
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR, decreasing = TRUE),]
  
  # Give a rank based on the normalized sum
  metric_df_normalized$Rank.from.Normalized.Sum = (1:nrow(metric_df_normalized))
  
  mean.Normalized.Sum.of.Presence.and.WR = 
    mean(metric_df_normalized$Normalized.Sum.of.Presence.and.WR)
  sd.Normalized.Sum.of.Presence.and.WR = 
    sd(metric_df_normalized$Normalized.Sum.of.Presence.and.WR)
  
  metric_df_normalized[tierNames[1]] = as.factor(case_when(
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR >= 
      mean.Normalized.Sum.of.Presence.and.WR + 
      3 * sd.Normalized.Sum.of.Presence.and.WR ~ "0",
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR >= 
      mean.Normalized.Sum.of.Presence.and.WR + 
      2 * sd.Normalized.Sum.of.Presence.and.WR ~ "0.5",
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR >= 
      mean.Normalized.Sum.of.Presence.and.WR + 
      1 * sd.Normalized.Sum.of.Presence.and.WR ~ "1",
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR >= 
      mean.Normalized.Sum.of.Presence.and.WR ~ "1.5",
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR >= 
      mean.Normalized.Sum.of.Presence.and.WR - 
      1 * sd.Normalized.Sum.of.Presence.and.WR ~ "2",
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR >= 
      mean.Normalized.Sum.of.Presence.and.WR - 
      2 * sd.Normalized.Sum.of.Presence.and.WR ~ "2.5",
    metric_df_normalized$Normalized.Sum.of.Presence.and.WR >= 
      mean.Normalized.Sum.of.Presence.and.WR - 
      3 * sd.Normalized.Sum.of.Presence.and.WR ~ "3",
    TRUE ~ "Other"
  ))
  
  # Order the rows based on the decreasing ranking according to that 
  # normalized sum
  metric_df_normalized_CI_tier = metric_df_normalized[order(
    metric_df_normalized$Lower.Bound.of.CI.on.WR, decreasing = TRUE),]
  
  # Give a rank based on the lower bound of the CI on the WR
  metric_df_normalized_CI_tier$Rank.of.Lower.Bound.of.CI.on.WR = 
    (1:nrow(metric_df_normalized_CI_tier))
  
  meanLower.Bound.of.CI.on.WR = mean(metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR)
  sdLower.Bound.of.CI.on.WR = sd(metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR)
  
  metric_df_normalized_CI_tier[tierNames[2]] = as.factor(case_when(
    metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR >= 
      meanLower.Bound.of.CI.on.WR + 3 * sdLower.Bound.of.CI.on.WR ~ "0",
    metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR >= 
      meanLower.Bound.of.CI.on.WR + 2 * sdLower.Bound.of.CI.on.WR ~ "0.5",
    metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR >= 
      meanLower.Bound.of.CI.on.WR + 1 * sdLower.Bound.of.CI.on.WR ~ "1",
    metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR >= 
      meanLower.Bound.of.CI.on.WR ~ "1.5",
    metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR >= 
      meanLower.Bound.of.CI.on.WR - 1 * sdLower.Bound.of.CI.on.WR ~ "2",
    metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR >= 
      meanLower.Bound.of.CI.on.WR - 2 * sdLower.Bound.of.CI.on.WR ~ "2.5",
    metric_df_normalized_CI_tier$Lower.Bound.of.CI.on.WR >= 
      meanLower.Bound.of.CI.on.WR - 3 * sdLower.Bound.of.CI.on.WR ~ "3",
    TRUE ~ "Other"
  ))
  
  return(metric_df_normalized_CI_tier)
}


#' Matchup data of the most present archetypes
#'
#' @param df the dataframe generated by generate_df() 
#' @param chartShare the value of the cut to be set in "Others" for an archetype.
#' It must be a numeric value. For a cut at 2%, use statShare=2 (not 0.02).
#' @param presence the definition of metagame presence (aka share) to use. 
#' It can be:
#' - "Copies": the number of lines in the dataframe dedicated to that archetype
#' - "Players": the number of different players piloting that archetype
#' - "Matches": the number of matches played by the archetype
#' @param archetype NA by default. If NA, generate a NxN matchup matrix.
#' Otherwise, if a string with an archetype name is given, return a single row,
#' for the matchups against the most played decks of the chosen archetype.
#'
#' @return a dataframe with multiple rows by archetype, one for each matchup.
#' Used for building the matchup matrix. Cut done by chartShare, with a maximum
#' of 18 lines.
#' @export
#'
#' @examples
generate_matchup_data = function(df, chartShare, presence, archetype = NA){
  
  df_gen = generate_metagame_data(df, chartShare, presence)
  maxArchetype = 17
  # Can only display up to 18 rows before the matrix becomes unreadable
  if(nrow(df_gen) >= maxArchetype){
    df_other_to_sum = df_gen[(maxArchetype-1):nrow(df_gen),]
    df_other = data.frame(Archetype = 
                            paste0("Other (each < ",min(df_gen[1:maxArchetype,]$Share),"%)"), 
                          Presence = sum(df_other_to_sum$Presence), 
                          Share = sum(df_other_to_sum$Share)
                          )
    df_gen = rbind(df_gen[1:maxArchetype,],df_other)
  }
  
  archetypeList = df_gen$Archetype
  otherName = as.character(tail(archetypeList, n = 1))
  
  win_matrix = ifelse(is.na(archetype),
                      list(matrix(0, ncol = nrow(df_gen), nrow = nrow(df_gen))),
                      list(matrix(0, ncol = nrow(df_gen), nrow = 1)))[[1]]
  
  rownames(win_matrix) = ifelse(is.na(archetype),
                                list(df_gen$Archetype),
                                archetype)[[1]]
  colnames(win_matrix) = df_gen$Archetype
  
  loss_matrix = win_matrix
  match_matrix = win_matrix
  wr_matrix = win_matrix
  wrCIMin_matrix = win_matrix
  wrCIMax_matrix = win_matrix

  if(is.na(archetype)){
    # Only iterate over rows where we have MU data
    conditionMUNotNull = !sapply(df$Matchups, function(x) length(x) == 0 )
    for (i in (1:nrow(df))[conditionMUNotNull]){
      
      archetype1I = df[i,]$Archetype$Archetype
      archetype1I = ifelse(archetype1I %in% archetypeList,archetype1I,otherName)
      matchesI = df[i,]$Matchups[[1]]
      
      for (j in 1:nrow(matchesI)){
        matchesIJ = matchesI[j,]
        archetype2IJ = matchesIJ$OpponentArchetype
        archetype2IJ = ifelse(archetype2IJ %in% archetypeList,
                              archetype2IJ, otherName)
        
        if(matchesIJ$Wins > matchesIJ$Losses){
          win_matrix[archetype1I, archetype2IJ] = 
            win_matrix[archetype1I, archetype2IJ] + 1
        }else if(matchesIJ$Wins < matchesIJ$Losses){
          loss_matrix[archetype1I, archetype2IJ] = 
            loss_matrix[archetype1I, archetype2IJ] + 1
        }
      }
    }
  }else{
    dfArchetype = df[df$Archetype$Archetype == archetype, ]
    conditionMUNotNull = 
      !sapply(dfArchetype$Matchups, function(x) length(x) == 0 )
    for (i in (1:nrow(dfArchetype))[conditionMUNotNull]){
      
      matchesI = dfArchetype[i,]$Matchups[[1]]
      
      for (j in 1:nrow(matchesI)){
        matchesIJ = matchesI[j,]
        archetype2IJ = matchesIJ$OpponentArchetype
        archetype2IJ = ifelse(archetype2IJ %in% archetypeList,
                              archetype2IJ, otherName)
        
        if(matchesIJ$Wins > matchesIJ$Losses){
          win_matrix[archetype, archetype2IJ] = 
            win_matrix[archetype, archetype2IJ] + 1
        }else if(matchesIJ$Wins < matchesIJ$Losses){
          loss_matrix[archetype, archetype2IJ] = 
            loss_matrix[archetype, archetype2IJ] + 1
        }
      }
    }
  }
  
  match_matrix = win_matrix + loss_matrix
  
  wr_matrix = round(win_matrix/match_matrix*100,digits = 1)
  
  for(i in 1:nrow(wrCIMin_matrix)){
    for(j in 1:ncol(wrCIMin_matrix)){
      wrCIMin_matrix[i,j] = 
        ifelse(match_matrix[i,j] > 0,
               binom.test(win_matrix[i,j], match_matrix[i,j], 
                          p=0.5,alternative="two.sided", 
                          conf.level=CIPercent)$conf.int[1],NA)
    }
  }
  wrCIMin_matrix = round(wrCIMin_matrix*100,digits = 1)
  
  for(i in 1:nrow(wrCIMax_matrix)){
    for(j in 1:ncol(wrCIMax_matrix)){
      wrCIMax_matrix[i,j] = 
        ifelse(match_matrix[i,j] > 0,
               binom.test(win_matrix[i,j], match_matrix[i,j], 
                          p=0.5,alternative="two.sided", 
                          conf.level=CIPercent)$conf.int[2],NA)
    }
  }
  wrCIMax_matrix = round(wrCIMax_matrix*100,digits = 1)
  
  arch1Vec = ifelse(is.na(archetype),
    list(rep(colnames(wr_matrix),each=nrow(wr_matrix))),
    archetype)[[1]]
  arch2Vec = rep(colnames(wr_matrix),nrow(wr_matrix)) 
  displayOrder = rep(1:nrow(wr_matrix),each=nrow(wr_matrix)) 
  share = rep(df_gen$Share,each=nrow(wr_matrix)) 
  winRateArch = rep(round(rowSums(win_matrix)/rowSums(match_matrix)*100,digit=1),each=nrow(wr_matrix)) 
  plotTableWR = data.frame(Archetype1 = arch1Vec, 
                           Archetype2 = arch2Vec,
                           MUWinrate = as.vector(t(wr_matrix)),
                           Wins = as.vector(t(win_matrix)),
                           Losses = as.vector(t(loss_matrix)),
                           Matches = as.vector(t(match_matrix)),
                           wrCIMax_matrix = as.vector(t(wrCIMin_matrix)),
                           WRCIMax = as.vector(t(wrCIMax_matrix)),
                           DisplayOrder = displayOrder,
                           Share = share, WinRateArch = winRateArch)
  plotTableWR$ArchShare1 = paste0("<span style = 'font-size:10pt'><b>",
                                  plotTableWR$Archetype1,"</b></span>",
                                  "<br>Share: ",plotTableWR$Share,
                                  " %<br>Win Rate: ",plotTableWR$WinRateArch,"%")
  plotTableWR$Archetype2 = paste0("vs ",plotTableWR$Archetype2)
  
  plotTableWR$Archetype2 = factor(plotTableWR$Archetype2, 
                                  levels = 
                                    unique(plotTableWR$Archetype2[order(
                                      plotTableWR$DisplayOrder)]), ordered=TRUE)
  
  plotTableWR$OutputText = paste0("<span style = 'font-size:8pt'>",
                                  plotTableWR$wrCIMax_matrix,"% - ",plotTableWR$WRCIMax,
                                  "%</span><br><b>",plotTableWR$MUWinrate,
                                  "%</b><br><span style = 'font-size:8pt'>",
                                  plotTableWR$Matches," matches</span>")
  
  
  return(plotTableWR)
}
